{
  "items": [
    {
      "title": "How to integrate Medium articles into Next.js portfolio for better SEO discovery",
      "pubDate": "2025-12-02 11:05:36",
      "link": "https://medium.com/@ali_farooqi/how-to-integrate-medium-articles-into-next-js-portfolio-for-better-seo-discovery-a50d8a804ea2?source=rss-195ef3d05aae------2",
      "guid": "https://medium.com/p/a50d8a804ea2",
      "author": "Ali Farooqi",
      "thumbnail": "",
      "description": "\n<p><em>Short version:</em> I pulled my Medium RSS feed into my Next.js App Router, rendered posts server-side as real HTML pages (with proper metadata, canonical links and social cards), and got far better SEO discoverability than just linking to Medium. Below is a step-by-step tutorial that walks through the exact pieces I used (with code snippets), why they help SEO, and how to tweak them for yourÂ site.</p>\n<blockquote>\n<strong><em>Important: </em></strong><em>Medium does not officially support this method. They can always block it or change theirÂ output</em>\n</blockquote>\n<h3>Why this helps SEO (quick rationale)</h3>\n<ol>\n<li>\n<strong>Server-side HTML</strong>: Crawlers love real HTML with metadata; rendering posts on your domain transfers authority and gives Google direct access to yourÂ content.</li>\n<li>\n<strong>Canonical + social meta</strong>: You control og: tags, structured data and &lt;link rel=\"canonical\"&gt; so search engines know the canonical source and show rich previews.</li>\n<li>\n<strong>Internal linking &amp; sitemap</strong>: Having posts on your domain lets you include them in your sitemap, internal link graph, and increases dwell time on yourÂ site.</li>\n<li>\n<strong>Faster Lighthouse/UX</strong>: You can optimize images, fonts, and markup on your own siteâ€Šâ€”â€ŠLighthouse improvements help SEO indirectly.</li>\n</ol>\n<h3>What I didâ€Šâ€”â€ŠfileÂ map</h3>\n<ul>\n<li>lib/medium.tsâ€Šâ€”â€Šfetches and parses Medium RSSÂ feed.</li>\n<li>app/blog/page.tsxâ€Šâ€”â€Šthe blog index that lists posts (server-side).</li>\n<li>app/blog/[slug]/page.tsxâ€Šâ€”â€Šthe individual post page with metadata, canonical link and renderedÂ HTML.</li>\n<li>app/blog/[slug]/style.scssâ€Šâ€”â€Šstyles for articleÂ content.</li>\n</ul>\n<p>(These are the concrete files I used in my repo; Iâ€™ll walk you through their roles and show the key code snippets.)</p>\n<h3>Step 1â€Šâ€”â€ŠFetch and parse Medium feed (lib/medium.ts)</h3>\n<p><strong>Goal:</strong> turn Medium RSS into a structured array of posts your Next.js app can consume. I fetch Mediumâ€™s RSS (e.g. https://medium.com/feed/@yourusername), parse it, and normalize fields (title, slug, date, content, image, canonicalLink).</p>\n<p>Key ideas:</p>\n<ul>\n<li>Do this server-side (in async functions) so your blog index and post pages are rendered with content available to crawlers.</li>\n<li>Cache results or use revalidate if you want periodic updates rather than hitting Medium on everyÂ request.</li>\n</ul>\n<p>Example (adapted from myÂ repo):</p>\n<pre>// lib/medium.ts<br>import Parser from \"rss-parser\";<br><br>type MediumPost = {<br>  title: string;<br>  slug: string;<br>  pubDate: string;<br>  content: string;         // HTML content from Medium<br>  link: string;            // original Medium URL<br>  image?: string;<br>  categories?: string[];<br>};<br><br>const parser = new Parser();<br><br>export async function fetchMediumPosts(): Promise&lt;MediumPost[]&gt; {<br>  const feed = await parser.parseURL(\"https://medium.com/feed/@yourusername\"); // Replace with your Meduim username<br>  return feed.items.map(item =&gt; {<br>    const title = item.title || \"Blog\";<br>    // generate slug from title or from item.link<br>    const slug = (item.link || title).split(\"/\").pop()?.split(\"?\")[0] || title.replace(/\\s+/g, \"-\").toLowerCase();<br>    return {<br>      title,<br>      slug,<br>      pubDate: item.pubDate || \"\",<br>      content: item[\"content:encoded\"] || item.content || \"\",<br>      link: item.link || \"\",<br>      image: (item.enclosure &amp;&amp; item.enclosure.url) || undefined,<br>      categories: item.categories || []<br>    };<br>  });<br>}</pre>\n<p>Why this matters for SEO: you get the full HTML content (content:encoded) to render on your domain, and you can pull the image for og:image.</p>\n<h3>Step 2â€Šâ€”â€ŠCreate a server-side blog index (app/blog/page.tsx)</h3>\n<p><strong>Goal:</strong> render a list of posts on /blog with SSR so search engines index all posts and their summaries.</p>\n<p>Key ideas:</p>\n<ul>\n<li>Use an <em>async</em> server component (App Router) that calls fetchMediumPosts() and returns HTML cards for eachÂ post.</li>\n<li>Include schema/meta on the page and ensure each post link points to /blog/[slug] on yourÂ domain.</li>\n</ul>\n<p>Example (adapted from myÂ repo):</p>\n<pre>// app/blog/page.tsx (Next.js /app route server component)<br>import Link from \"next/link\";<br>import { fetchMediumPosts } from \"@/lib/medium\";<br><br>export default async function BlogPage() {<br>  const posts = await fetchMediumPosts();<br>  return (<br>    &lt;main&gt;<br>      &lt;h1&gt;Blog&lt;/h1&gt;<br>      &lt;ul&gt;<br>        {posts.map(post =&gt; (<br>          &lt;li key={post.slug}&gt;<br>            &lt;article&gt;<br>              &lt;h2&gt;<br>                &lt;Link href={`/blog/${post.slug}`}&gt;{post.title}&lt;/Link&gt;<br>              &lt;/h2&gt;<br>              &lt;time dateTime={post.pubDate}&gt;{new Date(post.pubDate).toLocaleDateString()}&lt;/time&gt;<br>              &lt;p dangerouslySetInnerHTML={{ __html: post.content.slice(0, 300) + \"...\" }} /&gt;<br>              &lt;Link href={`/blog/${post.slug}`}&gt;Read more â†’&lt;/Link&gt;<br>            &lt;/article&gt;<br>          &lt;/li&gt;<br>        ))}<br>      &lt;/ul&gt;<br>    &lt;/main&gt;<br>  );<br>}</pre>\n<p><em>SEO tip: render an accessible summary (first 150â€“300 chars) and include the publish dateâ€Šâ€”â€Šboth are used in search snippets.</em></p>\n<h3>Step 3â€Šâ€”â€ŠRender individual posts with strong metadata (app/blog/[slug]/page.tsx)</h3>\n<p><strong>Goal:</strong> make each post a full HTML page on your domainÂ with:</p>\n<ul>\n<li>&lt;title&gt; and meta description,</li>\n<li>og: and Twitter cardÂ tags,</li>\n<li>&lt;link rel=\"canonical\"&gt; pointing to Medium <em>or</em> to your URL (decide based on where you want canonical authority),</li>\n<li>structured data (Article schema) if you want richÂ results.</li>\n</ul>\n<p>Important decision: <strong>canonical</strong>â€Šâ€”â€Šif you prefer Medium to remain canonical, set canonical to Medium link; if you want crawlers to index your copy as canonical (and avoid duplicate content issues), set canonical to your /blog/[slug]. In my case I set canonical to the Medium original to be safe, but still got SEO benefit from having the content on my site and proper open graph meta. (Pick what fits yourÂ goals.)</p>\n<p>Example server component (adapted):</p>\n<pre>// app/blog/[slug]/page.tsx<br>import { fetchMediumPosts } from \"@/lib/medium\";<br>import Head from \"next/head\";<br><br>type Props = { params: { slug: string } };<br>export default async function PostPage({ params }: Props) {<br>  const posts = await fetchMediumPosts();<br>  const post = posts.find(p =&gt; p.slug === params.slug);<br>  if (!post) {<br>    return &lt;p&gt;Post not found&lt;/p&gt;;<br>  }<br>  return (<br>    &lt;&gt;<br>      &lt;Head&gt;<br>        &lt;title&gt;{post.title} - My Name&lt;/title&gt;<br>        &lt;meta name=\"description\" content={`${post.title} - read on my site`} /&gt;<br>        &lt;link rel=\"canonical\" href={post.link} /&gt;<br>        &lt;meta property=\"og:title\" content={post.title} /&gt;<br>        &lt;meta property=\"og:description\" content={`${post.title} - read on my site`} /&gt;<br>        {post.image &amp;&amp; &lt;meta property=\"og:image\" content={post.image} /&gt;}<br>        &lt;meta property=\"og:type\" content=\"article\" /&gt;<br>        &lt;meta property=\"article:published_time\" content={post.pubDate} /&gt;<br>      &lt;/Head&gt;<br>      &lt;article className=\"article\"&gt;<br>        &lt;h1&gt;{post.title}&lt;/h1&gt;<br>        &lt;time dateTime={post.pubDate}&gt;{new Date(post.pubDate).toLocaleDateString()}&lt;/time&gt;<br>        &lt;div className=\"content\" dangerouslySetInnerHTML={{ __html: post.content }} /&gt;<br>      &lt;/article&gt;<br>    &lt;/&gt;<br>  );<br>}</pre>\n<p>Notes:</p>\n<ul>\n<li>dangerouslySetInnerHTML is used to render the Medium HTML. Before deploying, sanitize or whitelist any dangerous tags if youâ€™re concerned.</li>\n<li>Optionally add structured data JSON-LD inside &lt;Head&gt; for Article schema to increase chances for richÂ results.</li>\n</ul>\n<h3>Step 4â€Šâ€”â€ŠStyle the article (app/blog/[slug]/style.scss)</h3>\n<p><strong>Goal:</strong> ensure readable typography and responsive images (so Lighthouse score stays high), and make the content respect your siteâ€™s darkÂ mode.</p>\n<p>Key styleÂ points:</p>\n<ul>\n<li>Set max-width for article body, responsive images (max-width: 100%), pre/code styling, and typographic rhythm.</li>\n<li>Constrain large images (so they donâ€™t blow up layout) and lazy-load them where possible.</li>\n</ul>\n<p>Example (adapted):</p>\n<pre>// app/blog/[slug]/style.scss<br>.article {<br>  max-width: 760px;<br>  margin: 0 auto;<br>  line-height: 1.6;<br>  font-size: 18px;<br><br>  img {<br>    max-width: 100%;<br>    height: auto;<br>    display: block;<br>    margin: 1rem 0;<br>  }<br>  pre {<br>    overflow: auto;<br>    padding: 1rem;<br>    border-radius: 8px;<br>  }<br>  h1, h2, h3 {<br>    margin-top: 1.6rem;<br>    margin-bottom: 0.6rem;<br>  }<br>}</pre>\n<p>Small styling wins = big Lighthouse gains (image sizing, font-display, avoiding huge layoutÂ shifts).</p>\n<h3>Step 5â€Šâ€”â€ŠSitemap and internalÂ linking</h3>\n<p>Make sure your /blog/[slug] URLs are present in your sitemap.xml. In Next.js you can generate a sitemap that reads the posts (via fetchMediumPosts()) and emits URLs withÂ lastmod.</p>\n<p>Also:</p>\n<ul>\n<li>Add structured internal links (e.g., related posts, tags) to help crawlers discover and rank yourÂ content.</li>\n<li>Add rel=\"nofollow\" only where needed (sponsored/affiliate links), keep editorial links followable.</li>\n</ul>\n<p>SEO snippet (sitemap generator pseudo):</p>\n<pre>// app/sitemap.ts<br>import { MetadataRoute } from \"next\";<br>import { fetchMediumPosts } from \"@/lib/medium\";<br><br>export default async function sitemap(): Promise&lt;MetadataRoute.Sitemap&gt; {<br>  const baseUrl = \"https://alifarooqi.com\"; // Replace with your domain<br><br>  const mediumPosts = await fetchMediumPosts();<br><br>  const blogUrls = mediumPosts.map(post =&gt; ({<br>    url: `${baseUrl}/blog/${post.slug}`,<br>    lastModified: post.pubDate ? new Date(post.pubDate) : new Date(),<br>  }));<br><br>  return [<br>    {<br>      url: baseUrl,<br>      lastModified: new Date(),<br>    },<br>    {<br>      url: `${baseUrl}/blog`,<br>      lastModified: new Date(),<br>    },<br>    ...blogUrls,<br>  ];<br>}</pre>\n<h3>Optional: cache &amp; updateÂ strategy</h3>\n<ul>\n<li>\n<strong>Static at build time</strong>: If you deploy on Vercel and your Medium voice doesnâ€™t change often, fetch at build time (faster).</li>\n<li>\n<strong>Incremental revalidation</strong>: Use Next.js revalidate / ISR so new Medium posts appear after a fixed interval.</li>\n<li>\n<strong>On-demand revalidation</strong>: After you publish on Medium, call an API to revalidate the Next.js page(s) so your site refreshes instantly.</li>\n</ul>\n<h3>Pitfalls &amp;Â gotchas</h3>\n<ul>\n<li>\n<strong>Duplicate content</strong>: If Medium and your site both appear canonical for the same article, Google may choose one. Choose canonical intentionally.</li>\n<li>\n<strong>Images/Media</strong>: Medium-hosted image URLs can be large; consider copying important images to your CDN for performance.</li>\n<li>\n<strong>Sanitization</strong>: If you render raw HTML, ensure you sanitize or carefully trust the feed to avoidÂ XSS.</li>\n<li>\n<strong>Rate limit / feed changes</strong>: Medium feed may throttle; cache results and handle errors gracefully.</li>\n</ul>\n<h3>Results I saw (qualitative)</h3>\n<ul>\n<li>Better indexed posts on my domain (search queries showing my domain rather than justÂ Medium).</li>\n<li>Improved preview cards on LinkedIn/Twitter since I control og:Â meta.</li>\n<li>Lighthouse scores improved after optimizing article styles and image sizing on myÂ domain.</li>\n</ul>\n<h3>Final checklist before youÂ deploy</h3>\n<ul>\n<li>Choose canonical strategy (your site vsÂ Medium).</li>\n<li>Add structured data (Article JSON-LD).</li>\n<li>Add og:image, twitter:card and proper title/meta description perÂ post.</li>\n<li>Generate sitemap with /blog/*Â entries.</li>\n<li>Test with Googleâ€™s Rich Results/URL Inspection and run Lighthouse.</li>\n<li>Optionally rehost critical images on yourÂ CDN.</li>\n</ul>\n<h3>Links</h3>\n<ul>\n<li>GitHub: <a href=\"https://github.com/alifarooqi/ali-portfolio-blog/tree/main\">https://github.com/alifarooqi/ali-portfolio-blog/</a>\n</li>\n<li>Demo: <a href=\"https://alifarooqi.vercel.app/blog\">https://alifarooqi.vercel.app/blog</a>\n</li>\n</ul>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=a50d8a804ea2\" width=\"1\" height=\"1\" alt=\"\">\n",
      "content": "\n<p><em>Short version:</em> I pulled my Medium RSS feed into my Next.js App Router, rendered posts server-side as real HTML pages (with proper metadata, canonical links and social cards), and got far better SEO discoverability than just linking to Medium. Below is a step-by-step tutorial that walks through the exact pieces I used (with code snippets), why they help SEO, and how to tweak them for yourÂ site.</p>\n<blockquote>\n<strong><em>Important: </em></strong><em>Medium does not officially support this method. They can always block it or change theirÂ output</em>\n</blockquote>\n<h3>Why this helps SEO (quick rationale)</h3>\n<ol>\n<li>\n<strong>Server-side HTML</strong>: Crawlers love real HTML with metadata; rendering posts on your domain transfers authority and gives Google direct access to yourÂ content.</li>\n<li>\n<strong>Canonical + social meta</strong>: You control og: tags, structured data and &lt;link rel=\"canonical\"&gt; so search engines know the canonical source and show rich previews.</li>\n<li>\n<strong>Internal linking &amp; sitemap</strong>: Having posts on your domain lets you include them in your sitemap, internal link graph, and increases dwell time on yourÂ site.</li>\n<li>\n<strong>Faster Lighthouse/UX</strong>: You can optimize images, fonts, and markup on your own siteâ€Šâ€”â€ŠLighthouse improvements help SEO indirectly.</li>\n</ol>\n<h3>What I didâ€Šâ€”â€ŠfileÂ map</h3>\n<ul>\n<li>lib/medium.tsâ€Šâ€”â€Šfetches and parses Medium RSSÂ feed.</li>\n<li>app/blog/page.tsxâ€Šâ€”â€Šthe blog index that lists posts (server-side).</li>\n<li>app/blog/[slug]/page.tsxâ€Šâ€”â€Šthe individual post page with metadata, canonical link and renderedÂ HTML.</li>\n<li>app/blog/[slug]/style.scssâ€Šâ€”â€Šstyles for articleÂ content.</li>\n</ul>\n<p>(These are the concrete files I used in my repo; Iâ€™ll walk you through their roles and show the key code snippets.)</p>\n<h3>Step 1â€Šâ€”â€ŠFetch and parse Medium feed (lib/medium.ts)</h3>\n<p><strong>Goal:</strong> turn Medium RSS into a structured array of posts your Next.js app can consume. I fetch Mediumâ€™s RSS (e.g. https://medium.com/feed/@yourusername), parse it, and normalize fields (title, slug, date, content, image, canonicalLink).</p>\n<p>Key ideas:</p>\n<ul>\n<li>Do this server-side (in async functions) so your blog index and post pages are rendered with content available to crawlers.</li>\n<li>Cache results or use revalidate if you want periodic updates rather than hitting Medium on everyÂ request.</li>\n</ul>\n<p>Example (adapted from myÂ repo):</p>\n<pre>// lib/medium.ts<br>import Parser from \"rss-parser\";<br><br>type MediumPost = {<br>  title: string;<br>  slug: string;<br>  pubDate: string;<br>  content: string;         // HTML content from Medium<br>  link: string;            // original Medium URL<br>  image?: string;<br>  categories?: string[];<br>};<br><br>const parser = new Parser();<br><br>export async function fetchMediumPosts(): Promise&lt;MediumPost[]&gt; {<br>  const feed = await parser.parseURL(\"https://medium.com/feed/@yourusername\"); // Replace with your Meduim username<br>  return feed.items.map(item =&gt; {<br>    const title = item.title || \"Blog\";<br>    // generate slug from title or from item.link<br>    const slug = (item.link || title).split(\"/\").pop()?.split(\"?\")[0] || title.replace(/\\s+/g, \"-\").toLowerCase();<br>    return {<br>      title,<br>      slug,<br>      pubDate: item.pubDate || \"\",<br>      content: item[\"content:encoded\"] || item.content || \"\",<br>      link: item.link || \"\",<br>      image: (item.enclosure &amp;&amp; item.enclosure.url) || undefined,<br>      categories: item.categories || []<br>    };<br>  });<br>}</pre>\n<p>Why this matters for SEO: you get the full HTML content (content:encoded) to render on your domain, and you can pull the image for og:image.</p>\n<h3>Step 2â€Šâ€”â€ŠCreate a server-side blog index (app/blog/page.tsx)</h3>\n<p><strong>Goal:</strong> render a list of posts on /blog with SSR so search engines index all posts and their summaries.</p>\n<p>Key ideas:</p>\n<ul>\n<li>Use an <em>async</em> server component (App Router) that calls fetchMediumPosts() and returns HTML cards for eachÂ post.</li>\n<li>Include schema/meta on the page and ensure each post link points to /blog/[slug] on yourÂ domain.</li>\n</ul>\n<p>Example (adapted from myÂ repo):</p>\n<pre>// app/blog/page.tsx (Next.js /app route server component)<br>import Link from \"next/link\";<br>import { fetchMediumPosts } from \"@/lib/medium\";<br><br>export default async function BlogPage() {<br>  const posts = await fetchMediumPosts();<br>  return (<br>    &lt;main&gt;<br>      &lt;h1&gt;Blog&lt;/h1&gt;<br>      &lt;ul&gt;<br>        {posts.map(post =&gt; (<br>          &lt;li key={post.slug}&gt;<br>            &lt;article&gt;<br>              &lt;h2&gt;<br>                &lt;Link href={`/blog/${post.slug}`}&gt;{post.title}&lt;/Link&gt;<br>              &lt;/h2&gt;<br>              &lt;time dateTime={post.pubDate}&gt;{new Date(post.pubDate).toLocaleDateString()}&lt;/time&gt;<br>              &lt;p dangerouslySetInnerHTML={{ __html: post.content.slice(0, 300) + \"...\" }} /&gt;<br>              &lt;Link href={`/blog/${post.slug}`}&gt;Read more â†’&lt;/Link&gt;<br>            &lt;/article&gt;<br>          &lt;/li&gt;<br>        ))}<br>      &lt;/ul&gt;<br>    &lt;/main&gt;<br>  );<br>}</pre>\n<p><em>SEO tip: render an accessible summary (first 150â€“300 chars) and include the publish dateâ€Šâ€”â€Šboth are used in search snippets.</em></p>\n<h3>Step 3â€Šâ€”â€ŠRender individual posts with strong metadata (app/blog/[slug]/page.tsx)</h3>\n<p><strong>Goal:</strong> make each post a full HTML page on your domainÂ with:</p>\n<ul>\n<li>&lt;title&gt; and meta description,</li>\n<li>og: and Twitter cardÂ tags,</li>\n<li>&lt;link rel=\"canonical\"&gt; pointing to Medium <em>or</em> to your URL (decide based on where you want canonical authority),</li>\n<li>structured data (Article schema) if you want richÂ results.</li>\n</ul>\n<p>Important decision: <strong>canonical</strong>â€Šâ€”â€Šif you prefer Medium to remain canonical, set canonical to Medium link; if you want crawlers to index your copy as canonical (and avoid duplicate content issues), set canonical to your /blog/[slug]. In my case I set canonical to the Medium original to be safe, but still got SEO benefit from having the content on my site and proper open graph meta. (Pick what fits yourÂ goals.)</p>\n<p>Example server component (adapted):</p>\n<pre>// app/blog/[slug]/page.tsx<br>import { fetchMediumPosts } from \"@/lib/medium\";<br>import Head from \"next/head\";<br><br>type Props = { params: { slug: string } };<br>export default async function PostPage({ params }: Props) {<br>  const posts = await fetchMediumPosts();<br>  const post = posts.find(p =&gt; p.slug === params.slug);<br>  if (!post) {<br>    return &lt;p&gt;Post not found&lt;/p&gt;;<br>  }<br>  return (<br>    &lt;&gt;<br>      &lt;Head&gt;<br>        &lt;title&gt;{post.title} - My Name&lt;/title&gt;<br>        &lt;meta name=\"description\" content={`${post.title} - read on my site`} /&gt;<br>        &lt;link rel=\"canonical\" href={post.link} /&gt;<br>        &lt;meta property=\"og:title\" content={post.title} /&gt;<br>        &lt;meta property=\"og:description\" content={`${post.title} - read on my site`} /&gt;<br>        {post.image &amp;&amp; &lt;meta property=\"og:image\" content={post.image} /&gt;}<br>        &lt;meta property=\"og:type\" content=\"article\" /&gt;<br>        &lt;meta property=\"article:published_time\" content={post.pubDate} /&gt;<br>      &lt;/Head&gt;<br>      &lt;article className=\"article\"&gt;<br>        &lt;h1&gt;{post.title}&lt;/h1&gt;<br>        &lt;time dateTime={post.pubDate}&gt;{new Date(post.pubDate).toLocaleDateString()}&lt;/time&gt;<br>        &lt;div className=\"content\" dangerouslySetInnerHTML={{ __html: post.content }} /&gt;<br>      &lt;/article&gt;<br>    &lt;/&gt;<br>  );<br>}</pre>\n<p>Notes:</p>\n<ul>\n<li>dangerouslySetInnerHTML is used to render the Medium HTML. Before deploying, sanitize or whitelist any dangerous tags if youâ€™re concerned.</li>\n<li>Optionally add structured data JSON-LD inside &lt;Head&gt; for Article schema to increase chances for richÂ results.</li>\n</ul>\n<h3>Step 4â€Šâ€”â€ŠStyle the article (app/blog/[slug]/style.scss)</h3>\n<p><strong>Goal:</strong> ensure readable typography and responsive images (so Lighthouse score stays high), and make the content respect your siteâ€™s darkÂ mode.</p>\n<p>Key styleÂ points:</p>\n<ul>\n<li>Set max-width for article body, responsive images (max-width: 100%), pre/code styling, and typographic rhythm.</li>\n<li>Constrain large images (so they donâ€™t blow up layout) and lazy-load them where possible.</li>\n</ul>\n<p>Example (adapted):</p>\n<pre>// app/blog/[slug]/style.scss<br>.article {<br>  max-width: 760px;<br>  margin: 0 auto;<br>  line-height: 1.6;<br>  font-size: 18px;<br><br>  img {<br>    max-width: 100%;<br>    height: auto;<br>    display: block;<br>    margin: 1rem 0;<br>  }<br>  pre {<br>    overflow: auto;<br>    padding: 1rem;<br>    border-radius: 8px;<br>  }<br>  h1, h2, h3 {<br>    margin-top: 1.6rem;<br>    margin-bottom: 0.6rem;<br>  }<br>}</pre>\n<p>Small styling wins = big Lighthouse gains (image sizing, font-display, avoiding huge layoutÂ shifts).</p>\n<h3>Step 5â€Šâ€”â€ŠSitemap and internalÂ linking</h3>\n<p>Make sure your /blog/[slug] URLs are present in your sitemap.xml. In Next.js you can generate a sitemap that reads the posts (via fetchMediumPosts()) and emits URLs withÂ lastmod.</p>\n<p>Also:</p>\n<ul>\n<li>Add structured internal links (e.g., related posts, tags) to help crawlers discover and rank yourÂ content.</li>\n<li>Add rel=\"nofollow\" only where needed (sponsored/affiliate links), keep editorial links followable.</li>\n</ul>\n<p>SEO snippet (sitemap generator pseudo):</p>\n<pre>// app/sitemap.ts<br>import { MetadataRoute } from \"next\";<br>import { fetchMediumPosts } from \"@/lib/medium\";<br><br>export default async function sitemap(): Promise&lt;MetadataRoute.Sitemap&gt; {<br>  const baseUrl = \"https://alifarooqi.com\"; // Replace with your domain<br><br>  const mediumPosts = await fetchMediumPosts();<br><br>  const blogUrls = mediumPosts.map(post =&gt; ({<br>    url: `${baseUrl}/blog/${post.slug}`,<br>    lastModified: post.pubDate ? new Date(post.pubDate) : new Date(),<br>  }));<br><br>  return [<br>    {<br>      url: baseUrl,<br>      lastModified: new Date(),<br>    },<br>    {<br>      url: `${baseUrl}/blog`,<br>      lastModified: new Date(),<br>    },<br>    ...blogUrls,<br>  ];<br>}</pre>\n<h3>Optional: cache &amp; updateÂ strategy</h3>\n<ul>\n<li>\n<strong>Static at build time</strong>: If you deploy on Vercel and your Medium voice doesnâ€™t change often, fetch at build time (faster).</li>\n<li>\n<strong>Incremental revalidation</strong>: Use Next.js revalidate / ISR so new Medium posts appear after a fixed interval.</li>\n<li>\n<strong>On-demand revalidation</strong>: After you publish on Medium, call an API to revalidate the Next.js page(s) so your site refreshes instantly.</li>\n</ul>\n<h3>Pitfalls &amp;Â gotchas</h3>\n<ul>\n<li>\n<strong>Duplicate content</strong>: If Medium and your site both appear canonical for the same article, Google may choose one. Choose canonical intentionally.</li>\n<li>\n<strong>Images/Media</strong>: Medium-hosted image URLs can be large; consider copying important images to your CDN for performance.</li>\n<li>\n<strong>Sanitization</strong>: If you render raw HTML, ensure you sanitize or carefully trust the feed to avoidÂ XSS.</li>\n<li>\n<strong>Rate limit / feed changes</strong>: Medium feed may throttle; cache results and handle errors gracefully.</li>\n</ul>\n<h3>Results I saw (qualitative)</h3>\n<ul>\n<li>Better indexed posts on my domain (search queries showing my domain rather than justÂ Medium).</li>\n<li>Improved preview cards on LinkedIn/Twitter since I control og:Â meta.</li>\n<li>Lighthouse scores improved after optimizing article styles and image sizing on myÂ domain.</li>\n</ul>\n<h3>Final checklist before youÂ deploy</h3>\n<ul>\n<li>Choose canonical strategy (your site vsÂ Medium).</li>\n<li>Add structured data (Article JSON-LD).</li>\n<li>Add og:image, twitter:card and proper title/meta description perÂ post.</li>\n<li>Generate sitemap with /blog/*Â entries.</li>\n<li>Test with Googleâ€™s Rich Results/URL Inspection and run Lighthouse.</li>\n<li>Optionally rehost critical images on yourÂ CDN.</li>\n</ul>\n<h3>Links</h3>\n<ul>\n<li>GitHub: <a href=\"https://github.com/alifarooqi/ali-portfolio-blog/tree/main\">https://github.com/alifarooqi/ali-portfolio-blog/</a>\n</li>\n<li>Demo: <a href=\"https://alifarooqi.vercel.app/blog\">https://alifarooqi.vercel.app/blog</a>\n</li>\n</ul>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=a50d8a804ea2\" width=\"1\" height=\"1\" alt=\"\">\n",
      "enclosure": {},
      "categories": ["seo", "medium", "rss", "blog", "nextjs"]
    },
    {
      "title": "React vs Next.js: How Switching My Portfolio Improved SEO, Performance, and Core Web Vitals",
      "pubDate": "2025-12-02 10:20:47",
      "link": "https://medium.com/@ali_farooqi/react-vs-next-js-how-switching-my-portfolio-improved-seo-performance-and-core-web-vitals-756f9ff6c37d?source=rss-195ef3d05aae------2",
      "guid": "https://medium.com/p/756f9ff6c37d",
      "author": "Ali Farooqi",
      "thumbnail": "",
      "description": "\n<h3>React vs Next.js: How Switching My Portfolio Improved SEO, Performance, and Core Web Vitals by OverÂ 40%</h3>\n<p><em>And how a simple plan to add a blog turned into a full-blown SEOÂ glow-up.</em></p>\n<p>When I first rewrote my personal portfolio with <strong>Next.js</strong>, the motivation wasnâ€™t performance, search rankings, or achieving guru-level mastery of web vitals.<br> It was muchÂ simpler:</p>\n<p>ğŸ‘‰ <strong>I just wanted to add blogs to myÂ website.</strong></p>\n<p>But what happened next wasâ€¦ unexpected.</p>\n<p>After deploying the new Next.js version on <strong>Vercel</strong> and running a Lighthouse audit, I discovered that my siteâ€™s SEO, performance, accessibilityâ€Šâ€”â€Šbasically everythingâ€Šâ€”â€Šhad skyrocketed.</p>\n<p>So in this article, Iâ€™m sharing the exact <strong>React vs Next.js Lighthouse results</strong>, the percentage improvements, and why this migration unintentionally fixed my Core WebÂ Vitals.</p>\n<figure><img alt=\"Lighthouse score using Next.js showing almost-perfect performance score of 99\" src=\"https://cdn-images-1.medium.com/max/1024/1*xLZDsyguz_HiQKgEpetDcA.png\"><figcaption>Almost perfect performance score on Lighthouse useingÂ <strong>Next.js</strong></figcaption></figure><h3>ğŸš€ Why I Originally Built My Portfolio inÂ React</h3>\n<p>Like many developers, I started with a classic <strong>React + GitHub Pages</strong> setup. It was simple, familiar, and perfect for a static portfolio.</p>\n<figure><img alt=\"Lighthouse score using ReactJS showing performance score of 92\" src=\"https://cdn-images-1.medium.com/max/1024/1*LbyWVhFbrJbaD_lAtHxA1A.png\"><figcaption>I got an average 92 performance score usingÂ <strong>ReactJS</strong></figcaption></figure><p>But when I decided to start <strong>writing blogs</strong>, things gotÂ messy:</p>\n<ul>\n<li>No built-in routing for dynamicÂ pages</li>\n<li>Manual SEOÂ tags</li>\n<li>Everything was client-rendered</li>\n<li>GitHub Pages wasnâ€™t ideal for serving blogÂ content</li>\n</ul>\n<p>So I rebuilt everything in <strong>Next.js</strong>, mainly to get file-based routing and automatic SEO metadata.</p>\n<p>I wasnâ€™t expecting a 40%â€“60% improvement in performance as a side effectâ€Šâ€”â€Šbut here weÂ are.</p>\n<h3>ğŸ“Š Lighthouse Scoresâ€Šâ€”â€ŠReact vs Next.js (RealÂ Data)</h3>\n<p>I ran Lighthouse audits on both versions of my portfolio:</p>\n<pre>| Metric                       | React   | Next.js | Improvement    |<br>| ---------------------------- | ------- | ------- | -------------- |<br>| **First Contentful Paint**   | 1128 ms | 540 ms  | **52% faster** |<br>| **Largest Contentful Paint** | 1439 ms | 767 ms  | **47% faster** |<br>| **Speed Index**              | 1508 ms | 552 ms  | **63% faster** |</pre>\n<p>Thatâ€™s not a small â€œ<em>oh neat</em>â€ improvementâ€Šâ€”â€Šthatâ€™s a complete makeover.</p>\n<p>If my React site was a sedan, the Next.js rebuild turned it into a Tesla set to ludicrous mode.</p>\n<h3>ğŸ§  Why Next.js Performed So MuchÂ Better</h3>\n<p>Hereâ€™s what actually gave Next.js the advantageâ€Šâ€”â€Ševen without doing anything crazy in theÂ code.</p>\n<h4>âœ… 1. Server-Side Rendering (SSR) &amp; Static Optimization</h4>\n<p>My React build was <strong>fully client-rendered</strong>, meaning:</p>\n<ul>\n<li>The browser downloaded a large JSÂ bundle</li>\n<li>Then React hydrated everything</li>\n<li>Then the page becameÂ usable</li>\n</ul>\n<p>Next.js, on the otherÂ hand:</p>\n<ul>\n<li>Pre-rendered theÂ HTML</li>\n<li>Shipped less JavaScript</li>\n<li>Showed content immediately</li>\n</ul>\n<blockquote>Googleâ€™s crawler loves HTML. Next.js served GoogleÂ HTML.</blockquote>\n<blockquote>ğŸ‘‰ğŸ½ You can guess theÂ rest.</blockquote>\n<h4>âœ… 2. Vercelâ€™s Global EdgeÂ Network</h4>\n<p>GitHub Pages is great for hosting static files,Â but:</p>\n<ul>\n<li>No aggressive globalÂ CDN</li>\n<li>No image optimization</li>\n<li>No smart cachingÂ layer</li>\n</ul>\n<p>Vercel serves assets from edge nodes worldwide. This alone dropped my FCP by overÂ <strong>500ms</strong>.</p>\n<h4>âœ… 3. Automatic Image Optimization with next/image</h4>\n<p>Even using images â€œnormally,â€ Next.js silently:</p>\n<ul>\n<li>Converts formats</li>\n<li>Lazy loads</li>\n<li>Resizes</li>\n<li>Compresses</li>\n</ul>\n<p>React has none of this out of theÂ box.</p>\n<h4>âœ… 4. Route-Level Code Splitting</h4>\n<p>React + GitHub Pages = one big JavaScript bundle.</p>\n<p>Next.js =</p>\n<ul>\n<li>smaller chunks</li>\n<li>faster hydration</li>\n<li>less JS blocking theÂ UI</li>\n</ul>\n<p>Itâ€™s like carrying groceries in multiple small bags instead of one bag thatâ€™s trying to destroy yourÂ fingers.</p>\n<h4>âœ… 5. File-Based Routing + Metadata API â†’ BetterÂ SEO</h4>\n<p>The new blog automatically:</p>\n<ul>\n<li>Generates metadata</li>\n<li>Improves crawlability</li>\n<li>Creates predictable URL structures</li>\n<li>Allows pre-rendering ofÂ content</li>\n</ul>\n<p>All without touching react-helmet.</p>\n<h3>ğŸ”— Live Links andÂ Code</h3>\n<h4>React Portfolio (GitHubÂ Pages)</h4>\n<ul>\n<li>\n<strong>Live Demo:</strong> <a href=\"https://alifarooqi.github.io/\">https://alifarooqi.github.io/</a>\n</li>\n<li>\n<strong>Source Code:</strong> <a href=\"https://github.com/alifarooqi/alifarooqi.github.io\">https://github.com/alifarooqi/alifarooqi.github.io</a>\n</li>\n</ul>\n<h4>Next.js Portfolio (Vercel)</h4>\n<ul>\n<li>\n<strong>Live Demo:</strong> <a href=\"https://alifarooqi.vercel.app/\">https://alifarooqi.vercel.app/</a>\n</li>\n<li>\n<strong>Source Code:</strong> <a href=\"https://github.com/alifarooqi/ali-portfolio-blog\">https://github.com/alifarooqi/ali-portfolio-blog</a>\n</li>\n</ul>\n<p>Both are publicâ€Šâ€”â€Šfeel free to view the code or run your ownÂ audits.</p>\n<h3>ğŸ§© What I Learned from Accidentally Improving MyÂ SEO</h3>\n<p>I migrated to Next.jsÂ because:</p>\n<ul>\n<li>Itâ€™s great forÂ blogs</li>\n<li>Developer experience isÂ clean</li>\n<li>Routing is effortless</li>\n</ul>\n<p>But what I learned afterward is even more valuable:</p>\n<blockquote><strong>Next.js isnâ€™t just a frameworkâ€Šâ€”â€Šitâ€™s an SEOÂ upgrade.</strong></blockquote>\n<p>Performance, Core Web Vitals, and Lighthouse scores improve simplyÂ by:</p>\n<ul>\n<li>Using SSR/SSG</li>\n<li>Using Vercel</li>\n<li>Using automatic optimizations</li>\n</ul>\n<p>I didnâ€™t write special optimizations, redesign my site, or tune Webpack. Next.js simply did what React (alone) couldnâ€™t.</p>\n<h3>ğŸ¯ Final Thoughts (And Why You Might Want to SwitchÂ Too)</h3>\n<p>If youâ€™re building:</p>\n<ul>\n<li>A portfolio</li>\n<li>A blog</li>\n<li>A landingÂ page</li>\n<li>A content-heavy site</li>\n<li>Anything SEO-sensitive</li>\n</ul>\n<p>â€¦thereâ€™s almost no reason <strong>not</strong> to use Next.js inÂ 2025.</p>\n<p>You get SEO, performance, routing, metadata, and edge rendering right out of the box, without the yak-shaving.</p>\n<p><strong>React is amazingâ€Šâ€”â€Šno hate.<br></strong> But for production sites? Next.js just makes everythingâ€¦ <em>better</em>.</p>\n<p>If you want higher Lighthouse scores without doing 100 hours of optimization, Next.js might be the cheat code youâ€™re lookingÂ for.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=756f9ff6c37d\" width=\"1\" height=\"1\" alt=\"\">\n",
      "content": "\n<h3>React vs Next.js: How Switching My Portfolio Improved SEO, Performance, and Core Web Vitals by OverÂ 40%</h3>\n<p><em>And how a simple plan to add a blog turned into a full-blown SEOÂ glow-up.</em></p>\n<p>When I first rewrote my personal portfolio with <strong>Next.js</strong>, the motivation wasnâ€™t performance, search rankings, or achieving guru-level mastery of web vitals.<br> It was muchÂ simpler:</p>\n<p>ğŸ‘‰ <strong>I just wanted to add blogs to myÂ website.</strong></p>\n<p>But what happened next wasâ€¦ unexpected.</p>\n<p>After deploying the new Next.js version on <strong>Vercel</strong> and running a Lighthouse audit, I discovered that my siteâ€™s SEO, performance, accessibilityâ€Šâ€”â€Šbasically everythingâ€Šâ€”â€Šhad skyrocketed.</p>\n<p>So in this article, Iâ€™m sharing the exact <strong>React vs Next.js Lighthouse results</strong>, the percentage improvements, and why this migration unintentionally fixed my Core WebÂ Vitals.</p>\n<figure><img alt=\"Lighthouse score using Next.js showing almost-perfect performance score of 99\" src=\"https://cdn-images-1.medium.com/max/1024/1*xLZDsyguz_HiQKgEpetDcA.png\"><figcaption>Almost perfect performance score on Lighthouse useingÂ <strong>Next.js</strong></figcaption></figure><h3>ğŸš€ Why I Originally Built My Portfolio inÂ React</h3>\n<p>Like many developers, I started with a classic <strong>React + GitHub Pages</strong> setup. It was simple, familiar, and perfect for a static portfolio.</p>\n<figure><img alt=\"Lighthouse score using ReactJS showing performance score of 92\" src=\"https://cdn-images-1.medium.com/max/1024/1*LbyWVhFbrJbaD_lAtHxA1A.png\"><figcaption>I got an average 92 performance score usingÂ <strong>ReactJS</strong></figcaption></figure><p>But when I decided to start <strong>writing blogs</strong>, things gotÂ messy:</p>\n<ul>\n<li>No built-in routing for dynamicÂ pages</li>\n<li>Manual SEOÂ tags</li>\n<li>Everything was client-rendered</li>\n<li>GitHub Pages wasnâ€™t ideal for serving blogÂ content</li>\n</ul>\n<p>So I rebuilt everything in <strong>Next.js</strong>, mainly to get file-based routing and automatic SEO metadata.</p>\n<p>I wasnâ€™t expecting a 40%â€“60% improvement in performance as a side effectâ€Šâ€”â€Šbut here weÂ are.</p>\n<h3>ğŸ“Š Lighthouse Scoresâ€Šâ€”â€ŠReact vs Next.js (RealÂ Data)</h3>\n<p>I ran Lighthouse audits on both versions of my portfolio:</p>\n<pre>| Metric                       | React   | Next.js | Improvement    |<br>| ---------------------------- | ------- | ------- | -------------- |<br>| **First Contentful Paint**   | 1128 ms | 540 ms  | **52% faster** |<br>| **Largest Contentful Paint** | 1439 ms | 767 ms  | **47% faster** |<br>| **Speed Index**              | 1508 ms | 552 ms  | **63% faster** |</pre>\n<p>Thatâ€™s not a small â€œ<em>oh neat</em>â€ improvementâ€Šâ€”â€Šthatâ€™s a complete makeover.</p>\n<p>If my React site was a sedan, the Next.js rebuild turned it into a Tesla set to ludicrous mode.</p>\n<h3>ğŸ§  Why Next.js Performed So MuchÂ Better</h3>\n<p>Hereâ€™s what actually gave Next.js the advantageâ€Šâ€”â€Ševen without doing anything crazy in theÂ code.</p>\n<h4>âœ… 1. Server-Side Rendering (SSR) &amp; Static Optimization</h4>\n<p>My React build was <strong>fully client-rendered</strong>, meaning:</p>\n<ul>\n<li>The browser downloaded a large JSÂ bundle</li>\n<li>Then React hydrated everything</li>\n<li>Then the page becameÂ usable</li>\n</ul>\n<p>Next.js, on the otherÂ hand:</p>\n<ul>\n<li>Pre-rendered theÂ HTML</li>\n<li>Shipped less JavaScript</li>\n<li>Showed content immediately</li>\n</ul>\n<blockquote>Googleâ€™s crawler loves HTML. Next.js served GoogleÂ HTML.</blockquote>\n<blockquote>ğŸ‘‰ğŸ½ You can guess theÂ rest.</blockquote>\n<h4>âœ… 2. Vercelâ€™s Global EdgeÂ Network</h4>\n<p>GitHub Pages is great for hosting static files,Â but:</p>\n<ul>\n<li>No aggressive globalÂ CDN</li>\n<li>No image optimization</li>\n<li>No smart cachingÂ layer</li>\n</ul>\n<p>Vercel serves assets from edge nodes worldwide. This alone dropped my FCP by overÂ <strong>500ms</strong>.</p>\n<h4>âœ… 3. Automatic Image Optimization with next/image</h4>\n<p>Even using images â€œnormally,â€ Next.js silently:</p>\n<ul>\n<li>Converts formats</li>\n<li>Lazy loads</li>\n<li>Resizes</li>\n<li>Compresses</li>\n</ul>\n<p>React has none of this out of theÂ box.</p>\n<h4>âœ… 4. Route-Level Code Splitting</h4>\n<p>React + GitHub Pages = one big JavaScript bundle.</p>\n<p>Next.js =</p>\n<ul>\n<li>smaller chunks</li>\n<li>faster hydration</li>\n<li>less JS blocking theÂ UI</li>\n</ul>\n<p>Itâ€™s like carrying groceries in multiple small bags instead of one bag thatâ€™s trying to destroy yourÂ fingers.</p>\n<h4>âœ… 5. File-Based Routing + Metadata API â†’ BetterÂ SEO</h4>\n<p>The new blog automatically:</p>\n<ul>\n<li>Generates metadata</li>\n<li>Improves crawlability</li>\n<li>Creates predictable URL structures</li>\n<li>Allows pre-rendering ofÂ content</li>\n</ul>\n<p>All without touching react-helmet.</p>\n<h3>ğŸ”— Live Links andÂ Code</h3>\n<h4>React Portfolio (GitHubÂ Pages)</h4>\n<ul>\n<li>\n<strong>Live Demo:</strong> <a href=\"https://alifarooqi.github.io/\">https://alifarooqi.github.io/</a>\n</li>\n<li>\n<strong>Source Code:</strong> <a href=\"https://github.com/alifarooqi/alifarooqi.github.io\">https://github.com/alifarooqi/alifarooqi.github.io</a>\n</li>\n</ul>\n<h4>Next.js Portfolio (Vercel)</h4>\n<ul>\n<li>\n<strong>Live Demo:</strong> <a href=\"https://alifarooqi.vercel.app/\">https://alifarooqi.vercel.app/</a>\n</li>\n<li>\n<strong>Source Code:</strong> <a href=\"https://github.com/alifarooqi/ali-portfolio-blog\">https://github.com/alifarooqi/ali-portfolio-blog</a>\n</li>\n</ul>\n<p>Both are publicâ€Šâ€”â€Šfeel free to view the code or run your ownÂ audits.</p>\n<h3>ğŸ§© What I Learned from Accidentally Improving MyÂ SEO</h3>\n<p>I migrated to Next.jsÂ because:</p>\n<ul>\n<li>Itâ€™s great forÂ blogs</li>\n<li>Developer experience isÂ clean</li>\n<li>Routing is effortless</li>\n</ul>\n<p>But what I learned afterward is even more valuable:</p>\n<blockquote><strong>Next.js isnâ€™t just a frameworkâ€Šâ€”â€Šitâ€™s an SEOÂ upgrade.</strong></blockquote>\n<p>Performance, Core Web Vitals, and Lighthouse scores improve simplyÂ by:</p>\n<ul>\n<li>Using SSR/SSG</li>\n<li>Using Vercel</li>\n<li>Using automatic optimizations</li>\n</ul>\n<p>I didnâ€™t write special optimizations, redesign my site, or tune Webpack. Next.js simply did what React (alone) couldnâ€™t.</p>\n<h3>ğŸ¯ Final Thoughts (And Why You Might Want to SwitchÂ Too)</h3>\n<p>If youâ€™re building:</p>\n<ul>\n<li>A portfolio</li>\n<li>A blog</li>\n<li>A landingÂ page</li>\n<li>A content-heavy site</li>\n<li>Anything SEO-sensitive</li>\n</ul>\n<p>â€¦thereâ€™s almost no reason <strong>not</strong> to use Next.js inÂ 2025.</p>\n<p>You get SEO, performance, routing, metadata, and edge rendering right out of the box, without the yak-shaving.</p>\n<p><strong>React is amazingâ€Šâ€”â€Šno hate.<br></strong> But for production sites? Next.js just makes everythingâ€¦ <em>better</em>.</p>\n<p>If you want higher Lighthouse scores without doing 100 hours of optimization, Next.js might be the cheat code youâ€™re lookingÂ for.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=756f9ff6c37d\" width=\"1\" height=\"1\" alt=\"\">\n",
      "enclosure": {},
      "categories": ["react-vs-next", "lighthouse", "react", "seo", "nextjs"]
    },
    {
      "title": "AWS, Azure, or Alibaba Cloud: How to Open a Cloud Account in China",
      "pubDate": "2025-11-07 02:39:28",
      "link": "https://medium.com/@ali_farooqi/aws-azure-or-alibaba-cloud-how-to-open-a-cloud-account-in-china-7fe6870d9b57?source=rss-195ef3d05aae------2",
      "guid": "https://medium.com/p/7fe6870d9b57",
      "author": "Ali Farooqi",
      "thumbnail": "",
      "description": "\n<h3>The Trend I Couldnâ€™tÂ Ignore</h3>\n<p>A few weeks ago, while checking Google Trends for regional cloud interest, I noticed a sudden spike in searches for <em>â€œcloud account in Chinaâ€</em> around AugustÂ (2025).</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*SwKkSEcKUcPqdqk4SXyywQ.png\"><figcaption>The search trend spiked at the start of AugustÂ 2025</figcaption></figure><p>There are a few possible explanations. One is <strong>geopolitical</strong>: as global companies recalibrate data strategies amid evolving trade tensions and local data laws, hosting inside China has become both a compliance necessity and a competitive advantage. Another could be <strong>cost optimization </strong>with many organizations are realizing that routing traffic across the Great Firewall isnâ€™t just slow, itâ€™s expensive.</p>\n<p>Whatever the reason, the interest in Chinese cloud infrastructure has clearly hit the mainstream.</p>\n<h3>From â€œChina-Readyâ€ Apps to â€œChina-Readyâ€ Cloud</h3>\n<p>Earlier this year, I wrote an <a href=\"https://medium.com/@ali_farooqi/make-your-app-china-ready-how-to-deploy-web-services-inside-the-great-chinese-firewall-5aab4e1b08bd\">article</a> (and gave a talk) on <em>how to make your app â€œChina Readyâ€</em> covering network latency, localization, and compliance with Chinese dataÂ laws.</p>\n<p>But after the talk, one question kept comingÂ up:</p>\n<blockquote><strong><em>â€œHow do we actually open a cloud account inÂ China?â€</em></strong></blockquote>\n<p>That question sounds deceptively simple, but as anyone whoâ€™s tried knows, itâ€™s <em>not</em> straightforward. Even for a quick proof of concept (POC), you canâ€™t just sign up and deploy. Youâ€™ll need a <strong>registered business in China</strong> and an <strong>ICP license</strong> to legally host or serve web traffic inside theÂ country.</p>\n<h3>The Proper Way: Register a Business + Get an ICPÂ License</h3>\n<p>If your company is serious about long-term presence in China, the most compliant and stable route isÂ to:</p>\n<h4>\n<strong>1. Register a legal entity in China</strong> (a Wholly Foreign-Owned Enterprise, orÂ WFOE).</h4>\n<p>This gives you the ability to sign contracts, hire staff, and open a business bank accountâ€Šâ€”â€Šall prerequisites for most Chinese cloud providers.</p>\n<h4>\n<strong>2. Apply for an ICP license</strong> (Internet Content Provider license).</h4>\n<p>This license is required by the Ministry of Industry and Information Technology (MIIT) for hosting any website or app accessible in mainlandÂ China.</p>\n<p>The process can take a few weeks, and requires your business registration, Chinese contact address, and a local representative.</p>\n<p>Once you have both, you can apply for an enterprise cloud account with any of the major providersâ€Šâ€”â€Š<strong>Alibaba Cloud</strong>, <strong>AWS China</strong>, <strong>Azure China</strong>, or <strong>TencentÂ Cloud</strong>.</p>\n<h3>The Practical Way: Partner Through a Local ServiceÂ Provider</h3>\n<p>For teams that just want to test their product or deploy a limited internal environment, registering a company in China might be overkill.</p>\n<p>Thatâ€™s where <strong>service partners </strong>come in. Theyâ€™re licensed to hold ICPs and cloud resources on behalf of foreign clients. Through them, youÂ can:</p>\n<ul>\n<li>Get access to <strong>Chinese cloud infrastructure</strong> without forming a legalÂ entity.</li>\n<li>\n<strong>Host and serve web traffic</strong> inside China under theirÂ ICP.</li>\n<li>Set up your <strong>AWS China, Azure China, or Alibaba Cloud</strong> accounts in a compliant way.</li>\n</ul>\n<p><a href=\"https://open-bind.com/\"><strong><em>OpenBind</em></strong></a> (formerly <em>Great Wall Connect</em>) is one such consultancy that can help bridge the legal and operational gap for you, making it possible to go live inside the Great Firewall while staying compliant with local regulations.</p>\n<h3>Choosing Your Cloud: AWS, Azure, or AlibabaÂ Cloud</h3>\n<p>Cloud operators in China are completely isolated from their Global counterparts, which means you would need a separate account to run them. While <strong>AWS</strong> and <strong>Azure</strong> provide their services via their partners in China, local clouds platforms like <strong>Alibaba</strong>, <strong>Tencent</strong> or <strong>Huawei</strong> have a better suite of more localized services and have more trust of the Chinese consumers.</p>\n<p>Letâ€™s break down what to expect fromÂ each:</p>\n<ul>\n<li>\n<strong>AWS China (Beijing &amp; Ningxia regions)</strong>â€Šâ€”â€ŠOperated by Sinnet and NWCD respectively. The environment is isolated from global AWS, meaning separate accounts, endpoints, and credentials. <br>The services available in each region are different from each other, as well as different from the globalÂ AWS.</li>\n<li>\n<strong>Azure China</strong>â€Šâ€”â€ŠRun by 21Vianet. The interface and services are familiar, but again, completely separated from global Azure for compliance reasons.</li>\n<li>\n<strong>Alibaba Cloud</strong>â€Šâ€”â€ŠThe most mature local player with strong native integrations, but documentation can sometimes lag for EnglishÂ users.</li>\n<li>\n<strong>Tencent Cloudâ€Šâ€”</strong>â€ŠExcels for gaming and Superapp/Miniapp ecosystem with strong infrastructure for running low-latency apps.</li>\n</ul>\n<p>Each provider has its own quirks and approval flow. Opening the account through <a href=\"https://open-bind.com/\"><strong><em>OpenBind</em></strong></a> can streamline these, as they already work with the in-country operators.</p>\n<h3>The BottomÂ Line</h3>\n<p>The spike in searches for â€œcloud account in Chinaâ€ isnâ€™t just a curiosityâ€Šâ€”â€Šitâ€™s a reflection of a growing realization:</p>\n<blockquote><strong>You canâ€™t build a serious digital presence in China without goingÂ local.</strong></blockquote>\n<p>Whether you go the official route (business + ICP) or work with a licensed partner like <a href=\"https://open-bind.com/\"><strong><em>OpenBind</em></strong></a>, the key is to start early, plan your compliance, and pick the right cloud for your useÂ case.</p>\n<p>In 2025, being â€œChina Readyâ€ means being <strong>cloud-ready forÂ China</strong>.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=7fe6870d9b57\" width=\"1\" height=\"1\" alt=\"\">\n",
      "content": "\n<h3>The Trend I Couldnâ€™tÂ Ignore</h3>\n<p>A few weeks ago, while checking Google Trends for regional cloud interest, I noticed a sudden spike in searches for <em>â€œcloud account in Chinaâ€</em> around AugustÂ (2025).</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*SwKkSEcKUcPqdqk4SXyywQ.png\"><figcaption>The search trend spiked at the start of AugustÂ 2025</figcaption></figure><p>There are a few possible explanations. One is <strong>geopolitical</strong>: as global companies recalibrate data strategies amid evolving trade tensions and local data laws, hosting inside China has become both a compliance necessity and a competitive advantage. Another could be <strong>cost optimization </strong>with many organizations are realizing that routing traffic across the Great Firewall isnâ€™t just slow, itâ€™s expensive.</p>\n<p>Whatever the reason, the interest in Chinese cloud infrastructure has clearly hit the mainstream.</p>\n<h3>From â€œChina-Readyâ€ Apps to â€œChina-Readyâ€ Cloud</h3>\n<p>Earlier this year, I wrote an <a href=\"https://medium.com/@ali_farooqi/make-your-app-china-ready-how-to-deploy-web-services-inside-the-great-chinese-firewall-5aab4e1b08bd\">article</a> (and gave a talk) on <em>how to make your app â€œChina Readyâ€</em> covering network latency, localization, and compliance with Chinese dataÂ laws.</p>\n<p>But after the talk, one question kept comingÂ up:</p>\n<blockquote><strong><em>â€œHow do we actually open a cloud account inÂ China?â€</em></strong></blockquote>\n<p>That question sounds deceptively simple, but as anyone whoâ€™s tried knows, itâ€™s <em>not</em> straightforward. Even for a quick proof of concept (POC), you canâ€™t just sign up and deploy. Youâ€™ll need a <strong>registered business in China</strong> and an <strong>ICP license</strong> to legally host or serve web traffic inside theÂ country.</p>\n<h3>The Proper Way: Register a Business + Get an ICPÂ License</h3>\n<p>If your company is serious about long-term presence in China, the most compliant and stable route isÂ to:</p>\n<h4>\n<strong>1. Register a legal entity in China</strong> (a Wholly Foreign-Owned Enterprise, orÂ WFOE).</h4>\n<p>This gives you the ability to sign contracts, hire staff, and open a business bank accountâ€Šâ€”â€Šall prerequisites for most Chinese cloud providers.</p>\n<h4>\n<strong>2. Apply for an ICP license</strong> (Internet Content Provider license).</h4>\n<p>This license is required by the Ministry of Industry and Information Technology (MIIT) for hosting any website or app accessible in mainlandÂ China.</p>\n<p>The process can take a few weeks, and requires your business registration, Chinese contact address, and a local representative.</p>\n<p>Once you have both, you can apply for an enterprise cloud account with any of the major providersâ€Šâ€”â€Š<strong>Alibaba Cloud</strong>, <strong>AWS China</strong>, <strong>Azure China</strong>, or <strong>TencentÂ Cloud</strong>.</p>\n<h3>The Practical Way: Partner Through a Local ServiceÂ Provider</h3>\n<p>For teams that just want to test their product or deploy a limited internal environment, registering a company in China might be overkill.</p>\n<p>Thatâ€™s where <strong>service partners </strong>come in. Theyâ€™re licensed to hold ICPs and cloud resources on behalf of foreign clients. Through them, youÂ can:</p>\n<ul>\n<li>Get access to <strong>Chinese cloud infrastructure</strong> without forming a legalÂ entity.</li>\n<li>\n<strong>Host and serve web traffic</strong> inside China under theirÂ ICP.</li>\n<li>Set up your <strong>AWS China, Azure China, or Alibaba Cloud</strong> accounts in a compliant way.</li>\n</ul>\n<p><a href=\"https://open-bind.com/\"><strong><em>OpenBind</em></strong></a> (formerly <em>Great Wall Connect</em>) is one such consultancy that can help bridge the legal and operational gap for you, making it possible to go live inside the Great Firewall while staying compliant with local regulations.</p>\n<h3>Choosing Your Cloud: AWS, Azure, or AlibabaÂ Cloud</h3>\n<p>Cloud operators in China are completely isolated from their Global counterparts, which means you would need a separate account to run them. While <strong>AWS</strong> and <strong>Azure</strong> provide their services via their partners in China, local clouds platforms like <strong>Alibaba</strong>, <strong>Tencent</strong> or <strong>Huawei</strong> have a better suite of more localized services and have more trust of the Chinese consumers.</p>\n<p>Letâ€™s break down what to expect fromÂ each:</p>\n<ul>\n<li>\n<strong>AWS China (Beijing &amp; Ningxia regions)</strong>â€Šâ€”â€ŠOperated by Sinnet and NWCD respectively. The environment is isolated from global AWS, meaning separate accounts, endpoints, and credentials. <br>The services available in each region are different from each other, as well as different from the globalÂ AWS.</li>\n<li>\n<strong>Azure China</strong>â€Šâ€”â€ŠRun by 21Vianet. The interface and services are familiar, but again, completely separated from global Azure for compliance reasons.</li>\n<li>\n<strong>Alibaba Cloud</strong>â€Šâ€”â€ŠThe most mature local player with strong native integrations, but documentation can sometimes lag for EnglishÂ users.</li>\n<li>\n<strong>Tencent Cloudâ€Šâ€”</strong>â€ŠExcels for gaming and Superapp/Miniapp ecosystem with strong infrastructure for running low-latency apps.</li>\n</ul>\n<p>Each provider has its own quirks and approval flow. Opening the account through <a href=\"https://open-bind.com/\"><strong><em>OpenBind</em></strong></a> can streamline these, as they already work with the in-country operators.</p>\n<h3>The BottomÂ Line</h3>\n<p>The spike in searches for â€œcloud account in Chinaâ€ isnâ€™t just a curiosityâ€Šâ€”â€Šitâ€™s a reflection of a growing realization:</p>\n<blockquote><strong>You canâ€™t build a serious digital presence in China without goingÂ local.</strong></blockquote>\n<p>Whether you go the official route (business + ICP) or work with a licensed partner like <a href=\"https://open-bind.com/\"><strong><em>OpenBind</em></strong></a>, the key is to start early, plan your compliance, and pick the right cloud for your useÂ case.</p>\n<p>In 2025, being â€œChina Readyâ€ means being <strong>cloud-ready forÂ China</strong>.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=7fe6870d9b57\" width=\"1\" height=\"1\" alt=\"\">\n",
      "enclosure": {},
      "categories": [
        "alibabacloud",
        "cloud-platforms-in-china",
        "aws-china",
        "azure-china",
        "icp-license"
      ]
    },
    {
      "title": "Make Your App China-Ready: How to Deploy Web Services Inside the Great Chinese Firewall",
      "pubDate": "2025-10-28 05:33:27",
      "link": "https://medium.com/@ali_farooqi/make-your-app-china-ready-how-to-deploy-web-services-inside-the-great-chinese-firewall-5aab4e1b08bd?source=rss-195ef3d05aae------2",
      "guid": "https://medium.com/p/5aab4e1b08bd",
      "author": "Ali Farooqi",
      "thumbnail": "",
      "description": "\n<h3>Meta Description</h3>\n<blockquote><em>Discover how to deploy web services in Chinaâ€™s unique internet environment. Learn cloud-native strategies with Alibaba Cloud, Tencent Cloud &amp; the Great Firewall.</em></blockquote>\n<h3>Introduction</h3>\n<p>If your web app works beautifully everywhere, except Mainland China, youâ€™re notÂ alone.</p>\n<p>For developers, deploying inside the <strong>Great Firewall</strong> can feel like a mix of mystery and dark magic: some services time out, some APIs vanish, and CDNs that used to fly nowÂ crawl.</p>\n<p>In this guide, weâ€™ll go beyond translation and show you what it really takes to <strong>make your app China-ready</strong> - from cultural context to cloud deployment on <strong>Alibaba Cloud</strong>, <strong>Tencent Cloud</strong>, or <strong>HuaweiÂ Cloud</strong>.</p>\n<p>Whether youâ€™re a startup expanding east or a seasoned engineer curious about <strong>how to deploy web services in China</strong>, this walkthrough will give you a clear path through the wallâ€Šâ€”â€Šthe legalÂ way.</p>\n<h3>1. Why Chinaâ€™s Internet Is Different</h3>\n<p>Chinaâ€™s internet evolved on its own track. Adoption lagged the West by nearly a decade, and by the time mass users came online, smartphones were already everywhere.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*4cXfk3FQB29ysC_v5SPfuQ.png\"><figcaption>China adopted internet almost a decade after theÂ West</figcaption></figure><p>That meant <strong>China skipped the desktop era entirely</strong>â€Šâ€”â€Šit went mobile-first head-on.</p>\n<p>As a result, the ecosystem built around the mobile web: <em>super-apps</em>, mini-programs, dense UI design, and seamless mobile payments. Combine that with data localization rules and firewall routing, and you get a <strong>parallel internet infrastructure</strong>.</p>\n<h3>2. The Great Firewall and ItsÂ Impact</h3>\n<p>The <strong>Great Chinese Firewall</strong> isnâ€™t just censorshipâ€Šâ€”â€Šitâ€™s a complex network layer that filters, inspects, and shapes trafficÂ flow.</p>\n<p>From a developerâ€™s perspective, hereâ€™s what itÂ means:</p>\n<ul>\n<li>Cross-border traffic latency can increase by hundreds of milliseconds.</li>\n<li>Many third-party resources (Google APIs, YouTube, fonts, Firebase) are inaccessible.</li>\n<li>Global CDNs underperform or get throttled.</li>\n</ul>\n<p>In other words, your global cloud architecture isnâ€™t brokenâ€Šâ€”â€Šitâ€™s just <em>not optimized for the Chinese internet topology.</em></p>\n<h3>3. Cultural &amp; UX Differences ThatÂ Matter</h3>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/828/1*_7HP_g_rLhFRXsYllAvzyg.png\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/672/1*YipE7qDNVVhlJq-54O9FEw.png\"><figcaption>Taobao vs Amazonâ€Šâ€”â€ŠmobileÂ version</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*4B5k8l1NXaFdzAkSW1YEWg.png\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*uzmtZC1my7KwIOEz4iSxtQ.png\"><figcaption>Taobao vs Amazonâ€Šâ€”â€ŠdesktopÂ version</figcaption></figure><p>If you compare <strong>Taobao</strong> and <strong>Amazon</strong>, youâ€™ll notice it immediately:</p>\n<ul>\n<li>Taobao is dense, dynamic, animated, and full of micro-features.</li>\n<li>Amazon is minimal, structured, whitespace-driven.</li>\n</ul>\n<p>Chinese users expect <strong>speed, richness, and integration</strong>. They trust <em>apps</em>, not <em>websites.</em></p>\n<p>Design for this expectation:</p>\n<ul>\n<li>Mobile-first interactions.</li>\n<li>QR-code-based workflows.</li>\n<li>Embedded mini-programs and in-app experiences.</li>\n</ul>\n<p>Localization, in Chinaâ€™s case, means <strong>adapting to user psychology</strong>, not just changing textÂ strings.</p>\n<h3>4. Technical Challenges for Deploying inÂ China</h3>\n<p>Before you plan your rollout, understand the common blockers:</p>\n<ul>\n<li>\n<strong>Network latency:</strong> The Great Firewall slows down cross-border traffic.</li>\n<li>\n<strong>Blocked dependencies:</strong> Google Fonts, YouTube, Firebase, Cloudflare APIs oftenÂ fail.</li>\n<li>\n<strong>Hosting restrictions:</strong> Without an <strong>ICP license</strong>, you canâ€™t legally host inside MainlandÂ China.</li>\n<li>\n<strong>App distribution:</strong> Thereâ€™s no Google Playâ€Šâ€”â€Šexpect fragmented Android marketplaces.</li>\n<li>\n<strong>Analytics &amp; SDKs:</strong> Western tools often donâ€™t work; local SDKs like <strong>Umeng</strong> are usedÂ instead.</li>\n</ul>\n<p>Your tech stack might need regional forks or togglesâ€Šâ€”â€Šnot just a globalÂ clone.</p>\n<h3>5. Cloud Strategy: Deploying on ChineseÂ Clouds</h3>\n<p>To make your app fast and compliant, you need to deploy it closer to your users.<br>The three dominant cloud providers in ChinaÂ are:</p>\n<ul>\n<li>\n<strong>Alibaba Cloud (Aliyun)</strong>â€Šâ€”â€Šbroadest reach, developer-friendly APIs.</li>\n<li>\n<strong>Tencent Cloud</strong>â€Šâ€”â€Šstrong gaming, streaming, and mini-program integration.</li>\n<li>\n<strong>Huawei Cloud</strong>â€Šâ€”â€Šenterprise and hybrid infrastructure focus.</li>\n</ul>\n<p>Best practice:</p>\n<ul>\n<li>Use <strong>Mainland China regions</strong> for serving users inside the Great Firewall.</li>\n<li>Keep non-sensitive data or backups in <strong>Hong Kong/Singapore</strong> regions for redundancy.</li>\n<li>Combine the two using <strong>hybrid cloud deployment</strong> with region-aware routing.</li>\n</ul>\n<h3>6. Compliance Essentials: ICP andÂ MLPS</h3>\n<p>You canâ€™t deploy inside China without understanding compliance:</p>\n<h3>ICP License (å¤‡æ¡ˆ /Â è®¸å¯è¯)</h3>\n<ul>\n<li>Required for any public-facing site hosted in MainlandÂ China.</li>\n<li>Issued by the MIIT (Ministry of Industry and Information Technology).</li>\n<li>ICP Filing â†’ informational sites.</li>\n<li>ICP Commercial License â†’ apps generating revenue.</li>\n</ul>\n<h3>MLPS 2.0â€Šâ€”â€ŠMulti-Level Protection Scheme</h3>\n<ul>\n<li>Chinaâ€™s cybersecurity compliance framework.</li>\n<li>Level 2 is typical for SaaS/webÂ apps.</li>\n<li>Covers data protection, monitoring, incident response, encryption.</li>\n</ul>\n<p>Compliance isnâ€™t a blockerâ€Šâ€”â€Šitâ€™s an <strong>entry ticket</strong> to long-term stability.</p>\n<h3>7. Developer Playbook: Cloud-Native &amp; Firewall-Friendly</h3>\n<p>Hereâ€™s how to build and deploy web apps that actually perform insideÂ China:</p>\n<ul>\n<li>ğŸ§± <strong>Cloud-native mindset</strong>â€Šâ€”â€Šcontainerize everything.</li>\n<li>ğŸ³ <strong>Host your own Docker registry</strong> (Harbor or Alibaba Cloud ACR) since Docker Hub is slow or unreachable.</li>\n<li>â˜ï¸ <strong>Use local CDNs</strong>â€Šâ€”â€ŠAlibaba Cloud CDN, Tencent Cloud CDN, or BaishanÂ Cloud.</li>\n<li>ğŸ§­ <strong>Hybrid routing</strong>â€Šâ€”â€Šserve static assets inside CN, APIs from HK/SG for simplicity.</li>\n<li>ğŸ–‹ <strong>Self-host assets</strong>â€Šâ€”â€Šfonts, scripts, analytics.</li>\n<li>ğŸ“Š <strong>Local analytics</strong>â€Šâ€”â€ŠUmeng, Sensors Data, or OpenTelemetry for cross-region metrics.</li>\n<li>ğŸ§ª <strong>Simulate Mainland conditions</strong>â€Šâ€”â€Štest with VPN throttling or China-based probes.</li>\n</ul>\n<p>Think <em>â€œmulti-cloud + multi-regionâ€</em>, not <em>â€œone global region fitsÂ all.â€</em></p>\n<h3>8. The Developer MindsetÂ Shift</h3>\n<p>Most localization efforts stop at translation.<br>But real China-readiness requires a mindsetÂ shift:</p>\n<ul>\n<li>From <strong>monolithic</strong> â†’Â <strong>modular</strong>.</li>\n<li>From <strong>global CDN</strong> â†’ <strong>regional edgeÂ nodes.</strong>\n</li>\n<li>From <strong>foreign API dependence</strong> â†’ <strong>local integrations.</strong>\n</li>\n</ul>\n<p>Localization â‰  translationâ€Šâ€”â€Š<strong>itâ€™s architecture.</strong></p>\n<h3>9. Watch the Full Talk on YouTubeÂ ğŸ¥</h3>\n<p>ğŸ“º Watch the full talk: <em>â€œMake Your App China-Ready: Deploying Inside the Great Firewallâ€</em></p>\n<a href=\"https://medium.com/media/712eab9fd60d2c212867083672c99d9d/href\">https://medium.com/media/712eab9fd60d2c212867083672c99d9d/href</a><h3>10. Key Takeaways</h3>\n<p>âœ… The Great Firewall isnâ€™t an obstacleâ€Šâ€”â€Šitâ€™s an <em>environment</em> you design for.<br>âœ… Treat China as a <strong>region</strong>, not an exception.<br>âœ… Build <strong>cloud-native</strong> systems for portability across providers.<br>âœ… Replace global dependencies with <strong>local equivalents</strong>.<br>âœ… Compliance (ICP + MLPS) is part of your architecture.<br>âœ… Test from <em>inside China</em>, not outsideÂ it.</p>\n<h3>11. FinalÂ Thoughts</h3>\n<p>Deploying web services inside the <strong>Great Chinese Firewall</strong> isnâ€™t just about getting through filtersâ€Šâ€”â€Šitâ€™s about <strong>understanding how the ecosystem works</strong> and designing accordingly.</p>\n<p>If you can make your app China-ready, you can make it <em>anywhere-ready.</em></p>\n<h3>ğŸ§© SEOÂ Tags</h3>\n<p>Great Firewall, deploy in China, Chinese cloud, Alibaba Cloud, Tencent Cloud, Huawei Cloud, China web localization, ICP license, MLPS 2.0, China-ready app</p>\n<h3>Open Graph / Social Share ImageÂ Text</h3>\n<blockquote><em>â€œDeploy Web Apps in Chinaâ€Šâ€”â€ŠCloud-Native Strategies for the Great Firewallâ€</em></blockquote>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=5aab4e1b08bd\" width=\"1\" height=\"1\" alt=\"\">\n",
      "content": "\n<h3>Meta Description</h3>\n<blockquote><em>Discover how to deploy web services in Chinaâ€™s unique internet environment. Learn cloud-native strategies with Alibaba Cloud, Tencent Cloud &amp; the Great Firewall.</em></blockquote>\n<h3>Introduction</h3>\n<p>If your web app works beautifully everywhere, except Mainland China, youâ€™re notÂ alone.</p>\n<p>For developers, deploying inside the <strong>Great Firewall</strong> can feel like a mix of mystery and dark magic: some services time out, some APIs vanish, and CDNs that used to fly nowÂ crawl.</p>\n<p>In this guide, weâ€™ll go beyond translation and show you what it really takes to <strong>make your app China-ready</strong> - from cultural context to cloud deployment on <strong>Alibaba Cloud</strong>, <strong>Tencent Cloud</strong>, or <strong>HuaweiÂ Cloud</strong>.</p>\n<p>Whether youâ€™re a startup expanding east or a seasoned engineer curious about <strong>how to deploy web services in China</strong>, this walkthrough will give you a clear path through the wallâ€Šâ€”â€Šthe legalÂ way.</p>\n<h3>1. Why Chinaâ€™s Internet Is Different</h3>\n<p>Chinaâ€™s internet evolved on its own track. Adoption lagged the West by nearly a decade, and by the time mass users came online, smartphones were already everywhere.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*4cXfk3FQB29ysC_v5SPfuQ.png\"><figcaption>China adopted internet almost a decade after theÂ West</figcaption></figure><p>That meant <strong>China skipped the desktop era entirely</strong>â€Šâ€”â€Šit went mobile-first head-on.</p>\n<p>As a result, the ecosystem built around the mobile web: <em>super-apps</em>, mini-programs, dense UI design, and seamless mobile payments. Combine that with data localization rules and firewall routing, and you get a <strong>parallel internet infrastructure</strong>.</p>\n<h3>2. The Great Firewall and ItsÂ Impact</h3>\n<p>The <strong>Great Chinese Firewall</strong> isnâ€™t just censorshipâ€Šâ€”â€Šitâ€™s a complex network layer that filters, inspects, and shapes trafficÂ flow.</p>\n<p>From a developerâ€™s perspective, hereâ€™s what itÂ means:</p>\n<ul>\n<li>Cross-border traffic latency can increase by hundreds of milliseconds.</li>\n<li>Many third-party resources (Google APIs, YouTube, fonts, Firebase) are inaccessible.</li>\n<li>Global CDNs underperform or get throttled.</li>\n</ul>\n<p>In other words, your global cloud architecture isnâ€™t brokenâ€Šâ€”â€Šitâ€™s just <em>not optimized for the Chinese internet topology.</em></p>\n<h3>3. Cultural &amp; UX Differences ThatÂ Matter</h3>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/828/1*_7HP_g_rLhFRXsYllAvzyg.png\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/672/1*YipE7qDNVVhlJq-54O9FEw.png\"><figcaption>Taobao vs Amazonâ€Šâ€”â€ŠmobileÂ version</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*4B5k8l1NXaFdzAkSW1YEWg.png\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*uzmtZC1my7KwIOEz4iSxtQ.png\"><figcaption>Taobao vs Amazonâ€Šâ€”â€ŠdesktopÂ version</figcaption></figure><p>If you compare <strong>Taobao</strong> and <strong>Amazon</strong>, youâ€™ll notice it immediately:</p>\n<ul>\n<li>Taobao is dense, dynamic, animated, and full of micro-features.</li>\n<li>Amazon is minimal, structured, whitespace-driven.</li>\n</ul>\n<p>Chinese users expect <strong>speed, richness, and integration</strong>. They trust <em>apps</em>, not <em>websites.</em></p>\n<p>Design for this expectation:</p>\n<ul>\n<li>Mobile-first interactions.</li>\n<li>QR-code-based workflows.</li>\n<li>Embedded mini-programs and in-app experiences.</li>\n</ul>\n<p>Localization, in Chinaâ€™s case, means <strong>adapting to user psychology</strong>, not just changing textÂ strings.</p>\n<h3>4. Technical Challenges for Deploying inÂ China</h3>\n<p>Before you plan your rollout, understand the common blockers:</p>\n<ul>\n<li>\n<strong>Network latency:</strong> The Great Firewall slows down cross-border traffic.</li>\n<li>\n<strong>Blocked dependencies:</strong> Google Fonts, YouTube, Firebase, Cloudflare APIs oftenÂ fail.</li>\n<li>\n<strong>Hosting restrictions:</strong> Without an <strong>ICP license</strong>, you canâ€™t legally host inside MainlandÂ China.</li>\n<li>\n<strong>App distribution:</strong> Thereâ€™s no Google Playâ€Šâ€”â€Šexpect fragmented Android marketplaces.</li>\n<li>\n<strong>Analytics &amp; SDKs:</strong> Western tools often donâ€™t work; local SDKs like <strong>Umeng</strong> are usedÂ instead.</li>\n</ul>\n<p>Your tech stack might need regional forks or togglesâ€Šâ€”â€Šnot just a globalÂ clone.</p>\n<h3>5. Cloud Strategy: Deploying on ChineseÂ Clouds</h3>\n<p>To make your app fast and compliant, you need to deploy it closer to your users.<br>The three dominant cloud providers in ChinaÂ are:</p>\n<ul>\n<li>\n<strong>Alibaba Cloud (Aliyun)</strong>â€Šâ€”â€Šbroadest reach, developer-friendly APIs.</li>\n<li>\n<strong>Tencent Cloud</strong>â€Šâ€”â€Šstrong gaming, streaming, and mini-program integration.</li>\n<li>\n<strong>Huawei Cloud</strong>â€Šâ€”â€Šenterprise and hybrid infrastructure focus.</li>\n</ul>\n<p>Best practice:</p>\n<ul>\n<li>Use <strong>Mainland China regions</strong> for serving users inside the Great Firewall.</li>\n<li>Keep non-sensitive data or backups in <strong>Hong Kong/Singapore</strong> regions for redundancy.</li>\n<li>Combine the two using <strong>hybrid cloud deployment</strong> with region-aware routing.</li>\n</ul>\n<h3>6. Compliance Essentials: ICP andÂ MLPS</h3>\n<p>You canâ€™t deploy inside China without understanding compliance:</p>\n<h3>ICP License (å¤‡æ¡ˆ /Â è®¸å¯è¯)</h3>\n<ul>\n<li>Required for any public-facing site hosted in MainlandÂ China.</li>\n<li>Issued by the MIIT (Ministry of Industry and Information Technology).</li>\n<li>ICP Filing â†’ informational sites.</li>\n<li>ICP Commercial License â†’ apps generating revenue.</li>\n</ul>\n<h3>MLPS 2.0â€Šâ€”â€ŠMulti-Level Protection Scheme</h3>\n<ul>\n<li>Chinaâ€™s cybersecurity compliance framework.</li>\n<li>Level 2 is typical for SaaS/webÂ apps.</li>\n<li>Covers data protection, monitoring, incident response, encryption.</li>\n</ul>\n<p>Compliance isnâ€™t a blockerâ€Šâ€”â€Šitâ€™s an <strong>entry ticket</strong> to long-term stability.</p>\n<h3>7. Developer Playbook: Cloud-Native &amp; Firewall-Friendly</h3>\n<p>Hereâ€™s how to build and deploy web apps that actually perform insideÂ China:</p>\n<ul>\n<li>ğŸ§± <strong>Cloud-native mindset</strong>â€Šâ€”â€Šcontainerize everything.</li>\n<li>ğŸ³ <strong>Host your own Docker registry</strong> (Harbor or Alibaba Cloud ACR) since Docker Hub is slow or unreachable.</li>\n<li>â˜ï¸ <strong>Use local CDNs</strong>â€Šâ€”â€ŠAlibaba Cloud CDN, Tencent Cloud CDN, or BaishanÂ Cloud.</li>\n<li>ğŸ§­ <strong>Hybrid routing</strong>â€Šâ€”â€Šserve static assets inside CN, APIs from HK/SG for simplicity.</li>\n<li>ğŸ–‹ <strong>Self-host assets</strong>â€Šâ€”â€Šfonts, scripts, analytics.</li>\n<li>ğŸ“Š <strong>Local analytics</strong>â€Šâ€”â€ŠUmeng, Sensors Data, or OpenTelemetry for cross-region metrics.</li>\n<li>ğŸ§ª <strong>Simulate Mainland conditions</strong>â€Šâ€”â€Štest with VPN throttling or China-based probes.</li>\n</ul>\n<p>Think <em>â€œmulti-cloud + multi-regionâ€</em>, not <em>â€œone global region fitsÂ all.â€</em></p>\n<h3>8. The Developer MindsetÂ Shift</h3>\n<p>Most localization efforts stop at translation.<br>But real China-readiness requires a mindsetÂ shift:</p>\n<ul>\n<li>From <strong>monolithic</strong> â†’Â <strong>modular</strong>.</li>\n<li>From <strong>global CDN</strong> â†’ <strong>regional edgeÂ nodes.</strong>\n</li>\n<li>From <strong>foreign API dependence</strong> â†’ <strong>local integrations.</strong>\n</li>\n</ul>\n<p>Localization â‰  translationâ€Šâ€”â€Š<strong>itâ€™s architecture.</strong></p>\n<h3>9. Watch the Full Talk on YouTubeÂ ğŸ¥</h3>\n<p>ğŸ“º Watch the full talk: <em>â€œMake Your App China-Ready: Deploying Inside the Great Firewallâ€</em></p>\n<a href=\"https://medium.com/media/712eab9fd60d2c212867083672c99d9d/href\">https://medium.com/media/712eab9fd60d2c212867083672c99d9d/href</a><h3>10. Key Takeaways</h3>\n<p>âœ… The Great Firewall isnâ€™t an obstacleâ€Šâ€”â€Šitâ€™s an <em>environment</em> you design for.<br>âœ… Treat China as a <strong>region</strong>, not an exception.<br>âœ… Build <strong>cloud-native</strong> systems for portability across providers.<br>âœ… Replace global dependencies with <strong>local equivalents</strong>.<br>âœ… Compliance (ICP + MLPS) is part of your architecture.<br>âœ… Test from <em>inside China</em>, not outsideÂ it.</p>\n<h3>11. FinalÂ Thoughts</h3>\n<p>Deploying web services inside the <strong>Great Chinese Firewall</strong> isnâ€™t just about getting through filtersâ€Šâ€”â€Šitâ€™s about <strong>understanding how the ecosystem works</strong> and designing accordingly.</p>\n<p>If you can make your app China-ready, you can make it <em>anywhere-ready.</em></p>\n<h3>ğŸ§© SEOÂ Tags</h3>\n<p>Great Firewall, deploy in China, Chinese cloud, Alibaba Cloud, Tencent Cloud, Huawei Cloud, China web localization, ICP license, MLPS 2.0, China-ready app</p>\n<h3>Open Graph / Social Share ImageÂ Text</h3>\n<blockquote><em>â€œDeploy Web Apps in Chinaâ€Šâ€”â€ŠCloud-Native Strategies for the Great Firewallâ€</em></blockquote>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=5aab4e1b08bd\" width=\"1\" height=\"1\" alt=\"\">\n",
      "enclosure": {},
      "categories": [
        "chinese-cloud-service",
        "china-market",
        "web-development",
        "the-great-firewall",
        "hong-kong-web-dev"
      ]
    },
    {
      "title": "Integrating EJBCA (Community) with Scala &amp; Play Framework using CMP",
      "pubDate": "2025-10-28 03:29:37",
      "link": "https://medium.com/@ali_farooqi/integrating-ejbca-community-with-scala-play-framework-using-cmp-72330b4da4e5?source=rss-195ef3d05aae------2",
      "guid": "https://medium.com/p/72330b4da4e5",
      "author": "Ali Farooqi",
      "thumbnail": "",
      "description": "\n<p><em>Keywords: EJBCA CMP integration with Scala, CMP Play Framework, CMP client Scala, EJBCA community enrollment</em></p>\n<h3>TL;DR</h3>\n<p>This guide shows how to enable CMP on an EJBCA Community server and how to perform certificate <strong>enrollment (Init + Confirm)</strong>, <strong>renewal</strong>, and <strong>revocation</strong> from a Scala backend. Two client examples are included: one using Playâ€™s WSClient and another using Java 11 HttpClient. Production tips include using AWS S3 + KMS to back up and protect privateÂ keys.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*DZWSImeR70xT4Gnie3vppw.jpeg\"></figure><h3>1â€Šâ€”â€ŠQuick prerequisites (what youÂ need)</h3>\n<ul>\n<li>EJBCA Community Edition (latest Community release you can get; this guide uses HTTP CMP endpoints).</li>\n<li>Java 11+ (server &amp;Â client).</li>\n<li>Scala 2.13+ or 3.x and Play Framework 2.8+ if using PlayÂ example.</li>\n<li>BouncyCastle (bcprov, bcpkix) for CMP and ASN.1Â helpers.</li>\n</ul>\n<p>build.sbt (minimal):</p>\n<pre>libraryDependencies ++= Seq(<br>  \"com.typesafe.play\" %% \"play-ahc-ws\" % \"2.8.20\",    // Play WSClient<br>  \"org.bouncycastle\" % \"bcprov-jdk15on\" % \"1.74\",<br>  \"org.bouncycastle\" % \"bcpkix-jdk15on\" % \"1.74\"<br>)</pre>\n<blockquote><em>Note: adjust versions to match yourÂ project.</em></blockquote>\n<h3>2â€Šâ€”â€ŠEJBCA: enable CMP (HTTP) endpointâ€Šâ€”â€ŠquickÂ steps</h3>\n<ol>\n<li>Log into EJBCA AdminÂ GUI.</li>\n<li>Create/identify the CA you want to enroll certificates against.</li>\n<li>In <strong>System Configuration -&gt; CMP</strong> (or similar, depending on version):</li>\n</ol>\n<ul>\n<li>Add/enable an <strong>alias</strong> for HTTP CMP (e.g. cmpiam) and set a <em>shared secret</em> for password/mac (this is used with PKMAC inÂ CMP).</li>\n<li>Ensure the HTTP alias listens on the public web endpoint, usuallyÂ at:</li>\n</ul>\n<pre>http://&lt;ejbca-host&gt;/ejbca/publicweb/cmp/&lt;alias&gt;</pre>\n<p><em>(Your EJBCA version may use a slightly different base path; check your adminÂ UI.)</em></p>\n<ul><li>Ensure the CA has CMP enabled and the alias maps to it. You may need to trust the server certificate chain on yourÂ client.</li></ul>\n<h3>3â€Šâ€”â€ŠConfig (application.conf sample)</h3>\n<p>Minimal application.conf:</p>\n<pre>webpki {<br>  endpoint = \"http://ejbca.local/ejbca/publicweb/cmp/cmpiam\"<br>  protocolEncrKeyPem = \"\"\"-----BEGIN PUBLIC KEY----- ... -----END PUBLIC KEY-----\"\"\"<br>  issuer = \"CN=MyCA,O=MyOrg,C=HK\"<br>  certificateStorePath = \"/var/data/webpki\"<br>  domain = \"example.com\"<br>  timeoutMs = 10000<br>}</pre>\n<blockquote>Production<strong>:</strong> do <strong>NOT</strong> put secrets in plaintext. Use your secret manager. In production we used AWS KMS + S3 to encrypt and backup PKCS#12 files. I removed that from the runnable example to keep the guide focused and reproducible.</blockquote>\n<h3>4â€Šâ€”â€ŠCMP helpers (simplified CmpMessage)</h3>\n<p>This class builds <strong>Init</strong> and <strong>Confirm</strong> CMP messages and parses PKI messages returned by the CA. It is intentionally minimal: it produces the INIT request bytes and can parse the PKIMessage returned byÂ EJBCA.</p>\n<pre>package com.example.cmp<br><br>import org.bouncycastle.asn1.ASN1InputStream<br>import org.bouncycastle.asn1.cmp.{PKIBody, PKIMessage, ErrorMsgContent}<br>import org.bouncycastle.cert.cmp.{ProtectedPKIMessage, ProtectedPKIMessageBuilder}<br>import org.bouncycastle.cert.crmf.{CertificateRequestMessageBuilder, PKMACBuilder}<br>import org.bouncycastle.cert.crmf.jcajce.JcePKMACValuesCalculator<br>import org.bouncycastle.asn1.x500.X500Name<br>import org.bouncycastle.asn1.x509.SubjectPublicKeyInfo<br>import org.bouncycastle.asn1.{DEROctetString}<br>import org.bouncycastle.asn1.cmp.PKIBody.{TYPE_INIT_REQ, TYPE_CERT_CONFIRM}<br>import org.bouncycastle.asn1.crmf.CertReqMessages<br>import org.bouncycastle.asn1.cmp.PKIBody<br>import org.bouncycastle.asn1.cmp.PKIHeaderBuilder<br>import java.util.{Date, UUID}<br>import java.math.BigInteger<br>import java.security.SecureRandom<br>import java.io.ByteArrayInputStream<br>import play.api.libs.ws.WSResponse<br><br>class CmpMessage(val issuer: String, val protocolEncrPem: String, val macSecret: String) {<br>  private val jcePkmacCalc = new JcePKMACValuesCalculator()<br>  // SHA1 + HMAC/SHA1 config used for PKMACBuilder (EJBCA commonly supports PKMAC)<br>  // (You may customize algorithms here.)<br>  /** Build a minimal enrollment (INIT) CMP message as bytes */<br>  def createInitRequest(subject: String): Array[Byte] = {<br>    val issuerDN = new X500Name(issuer)<br>    val subjectDN = new X500Name(subject)<br>    val certReqId = BigInteger.valueOf(new SecureRandom().nextLong.abs)<br>    val sender = issuerDN // simple choice for demo<br>    val recipient = issuerDN<br>    val macCalculator = new PKMACBuilder(jcePkmacCalc).build(macSecret.toCharArray)<br>    val msg = new CertificateRequestMessageBuilder(certReqId)<br>      .setIssuer(issuerDN)<br>      .setSubject(subjectDN)<br>      .setPublicKey(null) // server will generate key; this is CRMF with ProtocolEncrKey control in real deployments<br>      .setAuthInfoSender(sender)<br>      .setProofOfPossessionRaVerified()<br>      .build()<br>    val msgs = new CertReqMessages(msg.toASN1Structure)<br>    val pkibody = new PKIBody(TYPE_INIT_REQ, msgs)<br>    val senderName = new org.bouncycastle.asn1.x509.GeneralName(issuerDN)<br>    val recipientName = new org.bouncycastle.asn1.x509.GeneralName(issuerDN)<br>    val protectedMsg = new ProtectedPKIMessageBuilder(senderName, recipientName)<br>      .setMessageTime(new Date())<br>      .setSenderNonce(UUID.randomUUID().toString.getBytes)<br>      .setTransactionID(UUID.randomUUID().toString.getBytes)<br>      .setBody(pkibody)<br>      .build(macCalculator)<br>    protectedMsg.toASN1Structure.getEncoded<br>  }<br>  /** Build a confirm request given the CA response PKIMessage */<br>  def createConfirmRequest(pkiResponse: PKIMessage): Array[Byte] = {<br>    val recipient = pkiResponse.getHeader.getSender<br>    val sender = pkiResponse.getHeader.getRecipient<br>    val nonce = pkiResponse.getHeader.getSenderNonce.getOctets<br>    val txId = pkiResponse.getHeader.getTransactionID.getOctets<br>    val certReqId = {<br>      val rep = pkiResponse.getBody.getContent.asInstanceOf[org.bouncycastle.asn1.cmp.CertRepMessage]<br>      rep.getResponse.head.getCertReqId.getValue<br>    }<br>    val pkiHeader = new PKIHeaderBuilder(2, sender, recipient)<br>      .setMessageTime(new org.bouncycastle.asn1.ASN1GeneralizedTime(new Date()))<br>      .setSenderNonce(new DEROctetString(nonce))<br>      .setTransactionID(new DEROctetString(txId))<br>      .build()<br>    val cs = new org.bouncycastle.asn1.cmp.CertStatus(UUID.randomUUID().toString.getBytes, certReqId)<br>    val cc = org.bouncycastle.asn1.cmp.CertConfirmContent.getInstance(new org.bouncycastle.asn1.DERSequence(cs))<br>    val myPKIBody = new PKIBody(TYPE_CERT_CONFIRM, cc)<br>    new PKIMessage(pkiHeader, myPKIBody).getEncoded<br>  }<br>  /** Parse an incoming PKI message from a WSResponse (bytes) */<br>  def parsePkiMessage(resp: WSResponse): PKIMessage = {<br>    val in = new ASN1InputStream(new ByteArrayInputStream(resp.body[Array[Byte]]))<br>    try {<br>      val obj = in.readObject()<br>      val pkiMessage = PKIMessage.getInstance(obj)<br>      pkiMessage.getBody.getType match {<br>        case PKIBody.TYPE_ERROR =&gt;<br>          val err = ErrorMsgContent.getInstance(pkiMessage.getBody.getContent)<br>          throw new RuntimeException(\"CA returned error: \" + err.getPKIStatusInfo.getStatusString.getStringAtUTF8(0).getString)<br>        case _ =&gt; pkiMessage<br>      }<br>    } finally in.close()<br>  }<br>}</pre>\n<blockquote>\n<strong>Note:</strong> The snippet intentionally omits ProtocolEncrKeyControl details and private-key decryption logic to keep the example compact. In production use, if the CA returns an encrypted private key, you must unwrap it (using your protocol private key) and assemble a PKCS#12 (see lowerÂ note).</blockquote>\n<h3>5â€Šâ€”â€ŠPlay WSClient: WebPkiService (enroll, confirm, renew,Â revoke)</h3>\n<p>A compact service using Play WSClient. This demonstrates sending bytes to the EJBCA CMP HTTP endpoint and handling responses.</p>\n<pre>package com.example.webpki<br>import play.api.libs.ws.WSClient<br>import play.api.libs.ws.DefaultBodyWritables._<br>import scala.concurrent.{ExecutionContext, Future}<br>import java.nio.file.{Paths, Files}<br>import java.nio.charset.StandardCharsets<br>class WebPkiService(ws: WSClient, cfg: play.api.Configuration, cmpMessage: com.example.cmp.CmpMessage)(implicit ec: ExecutionContext) {<br>  private val endpoint = cfg.get[String](\"webpki.endpoint\")<br>  private val storePath = cfg.get[String](\"webpki.certificateStorePath\")<br>  private val timeoutMs = cfg.get[Int](\"webpki.timeoutMs\")<br>  private def saveBytesAsFile(bytes: Array[Byte], filename: String): Unit = {<br>    Files.createDirectories(Paths.get(storePath))<br>    Files.write(Paths.get(storePath, filename), bytes)<br>  }<br>  /** Enroll: send INIT; parse response; send CONFIRM; store cert bytes (demo). */<br>  def enroll(subject: String, machineId: String): Future[Array[Byte]] = {<br>    val initBytes = cmpMessage.createInitRequest(subject)<br>    ws.url(endpoint)<br>      .withRequestTimeout(timeoutMs)<br>      .post(initBytes)<br>      .flatMap { resp =&gt;<br>        val pkiResp = cmpMessage.parsePkiMessage(resp)<br>        // For demo, createConfirmRequest needs PKIResponse<br>        val confirmBytes = cmpMessage.createConfirmRequest(pkiResp)<br>        ws.url(endpoint).post(confirmBytes).map { confResp =&gt;<br>          // In a real flow, confResp will confirm; the INIT response has the certificate.<br>          // For demonstration: save INIT response bytes as raw PKIMessage<br>          saveBytesAsFile(resp.body[Array[Byte]], s\"$machineId-init.pki\")<br>          saveBytesAsFile(confResp.body[Array[Byte]], s\"$machineId-confirm.pki\")<br>          // Optionally convert to PKCS12 if you implement toPkcs12.<br>          resp.body[Array[Byte]]<br>        }<br>      }<br>  }<br>  /** Renewal example - send a new INIT with 'renew' semantics (some CAs require special controls) */<br>  def renew(subject: String, machineId: String): Future[Array[Byte]] = {<br>    // For many CMP servers, renewal is similar to init but with appropriate control flags.<br>    // Here we reuse createInitRequest for simplicity.<br>    val initBytes = cmpMessage.createInitRequest(subject)<br>    ws.url(endpoint).post(initBytes).map { resp =&gt;<br>      saveBytesAsFile(resp.body[Array[Byte]], s\"$machineId-renew.pki\")<br>      resp.body[Array[Byte]]<br>    }<br>  }<br>  /** Revoke (simple HTTP call to an EJBCA RPC or REST endpoint would be typical).<br>    * CMP-based revocation exists, but often systems use RA/REST to revoke. We'll show a stub.<br>    */<br>  def revoke(certSerialNumber: String, reason: Int): Future[Unit] = {<br>    // EJBCA typically has REST endpoints for revocation (or CMP revocation message).<br>    // Example: POST to /ejbca/ejbca-rest-api/v1/certificate/revoke/{serial}<br>    val revokeUrl = cfg.get[String](\"webpki.revokeEndpoint\") // configure accordingly<br>    ws.url(revokeUrl)<br>      .withRequestTimeout(timeoutMs)<br>      .post(Map(\"serial\" -&gt; certSerialNumber, \"reason\" -&gt; reason.toString))<br>      .map(_ =&gt; ())<br>  }<br>}</pre>\n<p><strong>Notes</strong></p>\n<ul>\n<li>The code saves raw PKI bytes locally for inspection. In production you should parse/unwrap and build a PKCS#12 file; see nextÂ section.</li>\n<li>If the CA returns an encrypted private key, you must decrypt with your protocol private key and assemble a PKCS#12 keystore. That step was intentionally left as a comment/placeholder.</li>\n</ul>\n<h3>6â€Šâ€”â€ŠJava 11 HttpClient version (noÂ Play)</h3>\n<p>If you prefer not to depend on Play, hereâ€™s a minimal Java-HttpClient-based client for the sameÂ flow.</p>\n<pre>package com.example.webpki<br><br>import java.net.http.{HttpClient, HttpRequest, HttpResponse}<br>import java.net.URI<br>import java.time.Duration<br>import java.nio.file.{Files, Paths}<br>import scala.concurrent.{Future, ExecutionContext}<br>import scala.jdk.FutureConverters._<br>import java.net.http.HttpRequest.BodyPublishers<br>import java.net.http.HttpResponse.BodyHandlers<br>class WebPkiServiceJavaHttp(cfg: play.api.Configuration, cmpMessage: com.example.cmp.CmpMessage)(implicit ec: ExecutionContext) {<br>  private val endpoint = cfg.get[String](\"webpki.endpoint\")<br>  private val storePath = cfg.get[String](\"webpki.certificateStorePath\")<br>  private val timeoutMs = cfg.get[Int](\"webpki.timeoutMs\")<br>  private val client = HttpClient.newBuilder().connectTimeout(Duration.ofMillis(timeoutMs)).build()<br>  private def save(name: String, data: Array[Byte]): Unit = {<br>    Files.createDirectories(Paths.get(storePath))<br>    Files.write(Paths.get(storePath, name), data)<br>  }<br>  def enroll(subject: String, machineId: String): Future[Array[Byte]] = {<br>    val initBytes = cmpMessage.createInitRequest(subject)<br>    val req = HttpRequest.newBuilder(URI.create(endpoint))<br>      .timeout(Duration.ofMillis(timeoutMs))<br>      .header(\"Content-Type\", \"application/pkixcmp\")<br>      .POST(BodyPublishers.ofByteArray(initBytes))<br>      .build()<br>    client.sendAsync(req, BodyHandlers.ofByteArray()).thenCompose { resp =&gt;<br>      val body = resp.body()<br>      val pkiResp = /* you need parse bytes into PKIMessage; wrap in WSResponse-like helper */ {<br>        // For simplicity reuse a small adapter: parse bytes into PKIMessage (left as exercise)<br>        null<br>      }<br>      // In practice you'd convert bytes to PKIMessage and call createConfirmRequest<br>      // For demo we simply persist the response bytes and return them<br>      save(s\"$machineId-init.pki\", body)<br>      java.util.concurrent.CompletableFuture.completedFuture(body)<br>    }.asScala<br>  }<br>}</pre>\n<blockquote>The Java client version intentionally leaves the PKIMessage adaptation minimalâ€Šâ€”â€Šthe key idea is: you can use any HTTP client that posts application/pkixcmp bytes and reads the raw bytes back. Use BouncyCastle to parse the PKIÂ message.</blockquote>\n<h3>7â€Šâ€”â€ŠBuilding a PKCS#12 (production note)</h3>\n<p>Often EJBCA willÂ return:</p>\n<ul>\n<li>certificate chain, and optionally</li>\n<li>an encrypted private key that must be unwrapped with your Protocol PrivateÂ Key.</li>\n</ul>\n<p><strong>Production flow:</strong></p>\n<ol>\n<li>Use your protocol private key to unwrap the symmetric key (as shown in your original decryptPrivateKey logic).</li>\n<li>Decrypt private key bytes and combine with certificate chain to create a KeyStore of type PKCS12, then store() it to disk (orÂ S3).</li>\n<li>Protect the PKCS#12 password with your secret manager (KMS). In production we used <strong>KMS</strong> for password encryption and <strong>S3</strong> for backup of PKCS#12 files. This ensures you can recover certificates and keep them encrypted atÂ rest.</li>\n</ol>\n<h3>8â€Šâ€”â€ŠRenewal &amp; Revocation: when &amp;Â how</h3>\n<ul>\n<li>\n<strong>Renewal</strong>: Request a new certificate when expiry is near. CMP renewal usually looks like an init request with renewal controls or re-using existing CMP request flow. Some CMP servers accept ExplicitConfirm or specific controls. Test against your EJBCA configuration.</li>\n<li>\n<strong>Revocation</strong>: You can revoke via CMP (CMP supports revocation messages) or via EJBCA REST/CLI/admin endpoints. In many enterprise setups, RA systems call EJBCAâ€™s REST API for revocation since itâ€™s simpler to authenticate.</li>\n</ul>\n<h3>9â€Šâ€”â€ŠCommon pitfalls &amp; troubleshooting</h3>\n<ul>\n<li>\n<strong>Wrong shared secret</strong> â†’ PKMAC validation fails; EJBCA returns ErrorMsgContent. Check alias configuration andÂ secret.</li>\n<li>\n<strong>Certificates not present</strong> â†’ Ensure CA is allowed for CMP alias and the CA has the proper issuing certificate.</li>\n<li>\n<strong>Clock skew</strong> â†’ CMP messages include timestamps. Sync servers viaÂ NTP.</li>\n<li>\n<strong>Missing protocol keys</strong> â†’ If CA expects ProtocolEncrKeyControl, ensure you provide the CA public key in your CRMFÂ control.</li>\n<li>\n<strong>Content-Type</strong>: CMP HTTP expects application/pkixcmp for many deployments; ensure client sets thatÂ header.</li>\n</ul>\n<h3>10â€Šâ€”â€ŠSecurity &amp; production checklist</h3>\n<ul>\n<li>Use HTTPS endpoints for CMP (TLS). If using plain HTTP for testing, never do that in production.</li>\n<li>Protect <strong>macSecret</strong>, protocol private key, and PKCS#12 passwords using a secret manager. In production, we used <strong>AWS KMS</strong> to encrypt passwords and <strong>S3</strong> to store PKCS#12 blobsâ€Šâ€”â€Škeep them encrypted at rest and only decrypt in memory whenÂ needed.</li>\n<li>Rotate shared secrets and protocol keys according toÂ policy.</li>\n<li>Log <strong>only</strong> non-sensitive metadata. Do not log private key material or PKCS#12 password.</li>\n</ul>\n<h3>11â€Šâ€”â€ŠConclusion</h3>\n<p>Integrating EJBCA Community Edition with Scala is straightforward once CMP is enabled on the CA and you have the right cryptographic controls. This guide focused on core flows (Init + Confirm), renewal and revocation examples, and two client implementations (Play WSClient and Java 11 HttpClient). For production-grade deployments, combine CMP with secure key storage to keep certificate material safe and recoverable <em>(e.g., AWS KMS for protection and S3 for encrypted backups)</em>.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=72330b4da4e5\" width=\"1\" height=\"1\" alt=\"\">\n",
      "content": "\n<p><em>Keywords: EJBCA CMP integration with Scala, CMP Play Framework, CMP client Scala, EJBCA community enrollment</em></p>\n<h3>TL;DR</h3>\n<p>This guide shows how to enable CMP on an EJBCA Community server and how to perform certificate <strong>enrollment (Init + Confirm)</strong>, <strong>renewal</strong>, and <strong>revocation</strong> from a Scala backend. Two client examples are included: one using Playâ€™s WSClient and another using Java 11 HttpClient. Production tips include using AWS S3 + KMS to back up and protect privateÂ keys.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*DZWSImeR70xT4Gnie3vppw.jpeg\"></figure><h3>1â€Šâ€”â€ŠQuick prerequisites (what youÂ need)</h3>\n<ul>\n<li>EJBCA Community Edition (latest Community release you can get; this guide uses HTTP CMP endpoints).</li>\n<li>Java 11+ (server &amp;Â client).</li>\n<li>Scala 2.13+ or 3.x and Play Framework 2.8+ if using PlayÂ example.</li>\n<li>BouncyCastle (bcprov, bcpkix) for CMP and ASN.1Â helpers.</li>\n</ul>\n<p>build.sbt (minimal):</p>\n<pre>libraryDependencies ++= Seq(<br>  \"com.typesafe.play\" %% \"play-ahc-ws\" % \"2.8.20\",    // Play WSClient<br>  \"org.bouncycastle\" % \"bcprov-jdk15on\" % \"1.74\",<br>  \"org.bouncycastle\" % \"bcpkix-jdk15on\" % \"1.74\"<br>)</pre>\n<blockquote><em>Note: adjust versions to match yourÂ project.</em></blockquote>\n<h3>2â€Šâ€”â€ŠEJBCA: enable CMP (HTTP) endpointâ€Šâ€”â€ŠquickÂ steps</h3>\n<ol>\n<li>Log into EJBCA AdminÂ GUI.</li>\n<li>Create/identify the CA you want to enroll certificates against.</li>\n<li>In <strong>System Configuration -&gt; CMP</strong> (or similar, depending on version):</li>\n</ol>\n<ul>\n<li>Add/enable an <strong>alias</strong> for HTTP CMP (e.g. cmpiam) and set a <em>shared secret</em> for password/mac (this is used with PKMAC inÂ CMP).</li>\n<li>Ensure the HTTP alias listens on the public web endpoint, usuallyÂ at:</li>\n</ul>\n<pre>http://&lt;ejbca-host&gt;/ejbca/publicweb/cmp/&lt;alias&gt;</pre>\n<p><em>(Your EJBCA version may use a slightly different base path; check your adminÂ UI.)</em></p>\n<ul><li>Ensure the CA has CMP enabled and the alias maps to it. You may need to trust the server certificate chain on yourÂ client.</li></ul>\n<h3>3â€Šâ€”â€ŠConfig (application.conf sample)</h3>\n<p>Minimal application.conf:</p>\n<pre>webpki {<br>  endpoint = \"http://ejbca.local/ejbca/publicweb/cmp/cmpiam\"<br>  protocolEncrKeyPem = \"\"\"-----BEGIN PUBLIC KEY----- ... -----END PUBLIC KEY-----\"\"\"<br>  issuer = \"CN=MyCA,O=MyOrg,C=HK\"<br>  certificateStorePath = \"/var/data/webpki\"<br>  domain = \"example.com\"<br>  timeoutMs = 10000<br>}</pre>\n<blockquote>Production<strong>:</strong> do <strong>NOT</strong> put secrets in plaintext. Use your secret manager. In production we used AWS KMS + S3 to encrypt and backup PKCS#12 files. I removed that from the runnable example to keep the guide focused and reproducible.</blockquote>\n<h3>4â€Šâ€”â€ŠCMP helpers (simplified CmpMessage)</h3>\n<p>This class builds <strong>Init</strong> and <strong>Confirm</strong> CMP messages and parses PKI messages returned by the CA. It is intentionally minimal: it produces the INIT request bytes and can parse the PKIMessage returned byÂ EJBCA.</p>\n<pre>package com.example.cmp<br><br>import org.bouncycastle.asn1.ASN1InputStream<br>import org.bouncycastle.asn1.cmp.{PKIBody, PKIMessage, ErrorMsgContent}<br>import org.bouncycastle.cert.cmp.{ProtectedPKIMessage, ProtectedPKIMessageBuilder}<br>import org.bouncycastle.cert.crmf.{CertificateRequestMessageBuilder, PKMACBuilder}<br>import org.bouncycastle.cert.crmf.jcajce.JcePKMACValuesCalculator<br>import org.bouncycastle.asn1.x500.X500Name<br>import org.bouncycastle.asn1.x509.SubjectPublicKeyInfo<br>import org.bouncycastle.asn1.{DEROctetString}<br>import org.bouncycastle.asn1.cmp.PKIBody.{TYPE_INIT_REQ, TYPE_CERT_CONFIRM}<br>import org.bouncycastle.asn1.crmf.CertReqMessages<br>import org.bouncycastle.asn1.cmp.PKIBody<br>import org.bouncycastle.asn1.cmp.PKIHeaderBuilder<br>import java.util.{Date, UUID}<br>import java.math.BigInteger<br>import java.security.SecureRandom<br>import java.io.ByteArrayInputStream<br>import play.api.libs.ws.WSResponse<br><br>class CmpMessage(val issuer: String, val protocolEncrPem: String, val macSecret: String) {<br>  private val jcePkmacCalc = new JcePKMACValuesCalculator()<br>  // SHA1 + HMAC/SHA1 config used for PKMACBuilder (EJBCA commonly supports PKMAC)<br>  // (You may customize algorithms here.)<br>  /** Build a minimal enrollment (INIT) CMP message as bytes */<br>  def createInitRequest(subject: String): Array[Byte] = {<br>    val issuerDN = new X500Name(issuer)<br>    val subjectDN = new X500Name(subject)<br>    val certReqId = BigInteger.valueOf(new SecureRandom().nextLong.abs)<br>    val sender = issuerDN // simple choice for demo<br>    val recipient = issuerDN<br>    val macCalculator = new PKMACBuilder(jcePkmacCalc).build(macSecret.toCharArray)<br>    val msg = new CertificateRequestMessageBuilder(certReqId)<br>      .setIssuer(issuerDN)<br>      .setSubject(subjectDN)<br>      .setPublicKey(null) // server will generate key; this is CRMF with ProtocolEncrKey control in real deployments<br>      .setAuthInfoSender(sender)<br>      .setProofOfPossessionRaVerified()<br>      .build()<br>    val msgs = new CertReqMessages(msg.toASN1Structure)<br>    val pkibody = new PKIBody(TYPE_INIT_REQ, msgs)<br>    val senderName = new org.bouncycastle.asn1.x509.GeneralName(issuerDN)<br>    val recipientName = new org.bouncycastle.asn1.x509.GeneralName(issuerDN)<br>    val protectedMsg = new ProtectedPKIMessageBuilder(senderName, recipientName)<br>      .setMessageTime(new Date())<br>      .setSenderNonce(UUID.randomUUID().toString.getBytes)<br>      .setTransactionID(UUID.randomUUID().toString.getBytes)<br>      .setBody(pkibody)<br>      .build(macCalculator)<br>    protectedMsg.toASN1Structure.getEncoded<br>  }<br>  /** Build a confirm request given the CA response PKIMessage */<br>  def createConfirmRequest(pkiResponse: PKIMessage): Array[Byte] = {<br>    val recipient = pkiResponse.getHeader.getSender<br>    val sender = pkiResponse.getHeader.getRecipient<br>    val nonce = pkiResponse.getHeader.getSenderNonce.getOctets<br>    val txId = pkiResponse.getHeader.getTransactionID.getOctets<br>    val certReqId = {<br>      val rep = pkiResponse.getBody.getContent.asInstanceOf[org.bouncycastle.asn1.cmp.CertRepMessage]<br>      rep.getResponse.head.getCertReqId.getValue<br>    }<br>    val pkiHeader = new PKIHeaderBuilder(2, sender, recipient)<br>      .setMessageTime(new org.bouncycastle.asn1.ASN1GeneralizedTime(new Date()))<br>      .setSenderNonce(new DEROctetString(nonce))<br>      .setTransactionID(new DEROctetString(txId))<br>      .build()<br>    val cs = new org.bouncycastle.asn1.cmp.CertStatus(UUID.randomUUID().toString.getBytes, certReqId)<br>    val cc = org.bouncycastle.asn1.cmp.CertConfirmContent.getInstance(new org.bouncycastle.asn1.DERSequence(cs))<br>    val myPKIBody = new PKIBody(TYPE_CERT_CONFIRM, cc)<br>    new PKIMessage(pkiHeader, myPKIBody).getEncoded<br>  }<br>  /** Parse an incoming PKI message from a WSResponse (bytes) */<br>  def parsePkiMessage(resp: WSResponse): PKIMessage = {<br>    val in = new ASN1InputStream(new ByteArrayInputStream(resp.body[Array[Byte]]))<br>    try {<br>      val obj = in.readObject()<br>      val pkiMessage = PKIMessage.getInstance(obj)<br>      pkiMessage.getBody.getType match {<br>        case PKIBody.TYPE_ERROR =&gt;<br>          val err = ErrorMsgContent.getInstance(pkiMessage.getBody.getContent)<br>          throw new RuntimeException(\"CA returned error: \" + err.getPKIStatusInfo.getStatusString.getStringAtUTF8(0).getString)<br>        case _ =&gt; pkiMessage<br>      }<br>    } finally in.close()<br>  }<br>}</pre>\n<blockquote>\n<strong>Note:</strong> The snippet intentionally omits ProtocolEncrKeyControl details and private-key decryption logic to keep the example compact. In production use, if the CA returns an encrypted private key, you must unwrap it (using your protocol private key) and assemble a PKCS#12 (see lowerÂ note).</blockquote>\n<h3>5â€Šâ€”â€ŠPlay WSClient: WebPkiService (enroll, confirm, renew,Â revoke)</h3>\n<p>A compact service using Play WSClient. This demonstrates sending bytes to the EJBCA CMP HTTP endpoint and handling responses.</p>\n<pre>package com.example.webpki<br>import play.api.libs.ws.WSClient<br>import play.api.libs.ws.DefaultBodyWritables._<br>import scala.concurrent.{ExecutionContext, Future}<br>import java.nio.file.{Paths, Files}<br>import java.nio.charset.StandardCharsets<br>class WebPkiService(ws: WSClient, cfg: play.api.Configuration, cmpMessage: com.example.cmp.CmpMessage)(implicit ec: ExecutionContext) {<br>  private val endpoint = cfg.get[String](\"webpki.endpoint\")<br>  private val storePath = cfg.get[String](\"webpki.certificateStorePath\")<br>  private val timeoutMs = cfg.get[Int](\"webpki.timeoutMs\")<br>  private def saveBytesAsFile(bytes: Array[Byte], filename: String): Unit = {<br>    Files.createDirectories(Paths.get(storePath))<br>    Files.write(Paths.get(storePath, filename), bytes)<br>  }<br>  /** Enroll: send INIT; parse response; send CONFIRM; store cert bytes (demo). */<br>  def enroll(subject: String, machineId: String): Future[Array[Byte]] = {<br>    val initBytes = cmpMessage.createInitRequest(subject)<br>    ws.url(endpoint)<br>      .withRequestTimeout(timeoutMs)<br>      .post(initBytes)<br>      .flatMap { resp =&gt;<br>        val pkiResp = cmpMessage.parsePkiMessage(resp)<br>        // For demo, createConfirmRequest needs PKIResponse<br>        val confirmBytes = cmpMessage.createConfirmRequest(pkiResp)<br>        ws.url(endpoint).post(confirmBytes).map { confResp =&gt;<br>          // In a real flow, confResp will confirm; the INIT response has the certificate.<br>          // For demonstration: save INIT response bytes as raw PKIMessage<br>          saveBytesAsFile(resp.body[Array[Byte]], s\"$machineId-init.pki\")<br>          saveBytesAsFile(confResp.body[Array[Byte]], s\"$machineId-confirm.pki\")<br>          // Optionally convert to PKCS12 if you implement toPkcs12.<br>          resp.body[Array[Byte]]<br>        }<br>      }<br>  }<br>  /** Renewal example - send a new INIT with 'renew' semantics (some CAs require special controls) */<br>  def renew(subject: String, machineId: String): Future[Array[Byte]] = {<br>    // For many CMP servers, renewal is similar to init but with appropriate control flags.<br>    // Here we reuse createInitRequest for simplicity.<br>    val initBytes = cmpMessage.createInitRequest(subject)<br>    ws.url(endpoint).post(initBytes).map { resp =&gt;<br>      saveBytesAsFile(resp.body[Array[Byte]], s\"$machineId-renew.pki\")<br>      resp.body[Array[Byte]]<br>    }<br>  }<br>  /** Revoke (simple HTTP call to an EJBCA RPC or REST endpoint would be typical).<br>    * CMP-based revocation exists, but often systems use RA/REST to revoke. We'll show a stub.<br>    */<br>  def revoke(certSerialNumber: String, reason: Int): Future[Unit] = {<br>    // EJBCA typically has REST endpoints for revocation (or CMP revocation message).<br>    // Example: POST to /ejbca/ejbca-rest-api/v1/certificate/revoke/{serial}<br>    val revokeUrl = cfg.get[String](\"webpki.revokeEndpoint\") // configure accordingly<br>    ws.url(revokeUrl)<br>      .withRequestTimeout(timeoutMs)<br>      .post(Map(\"serial\" -&gt; certSerialNumber, \"reason\" -&gt; reason.toString))<br>      .map(_ =&gt; ())<br>  }<br>}</pre>\n<p><strong>Notes</strong></p>\n<ul>\n<li>The code saves raw PKI bytes locally for inspection. In production you should parse/unwrap and build a PKCS#12 file; see nextÂ section.</li>\n<li>If the CA returns an encrypted private key, you must decrypt with your protocol private key and assemble a PKCS#12 keystore. That step was intentionally left as a comment/placeholder.</li>\n</ul>\n<h3>6â€Šâ€”â€ŠJava 11 HttpClient version (noÂ Play)</h3>\n<p>If you prefer not to depend on Play, hereâ€™s a minimal Java-HttpClient-based client for the sameÂ flow.</p>\n<pre>package com.example.webpki<br><br>import java.net.http.{HttpClient, HttpRequest, HttpResponse}<br>import java.net.URI<br>import java.time.Duration<br>import java.nio.file.{Files, Paths}<br>import scala.concurrent.{Future, ExecutionContext}<br>import scala.jdk.FutureConverters._<br>import java.net.http.HttpRequest.BodyPublishers<br>import java.net.http.HttpResponse.BodyHandlers<br>class WebPkiServiceJavaHttp(cfg: play.api.Configuration, cmpMessage: com.example.cmp.CmpMessage)(implicit ec: ExecutionContext) {<br>  private val endpoint = cfg.get[String](\"webpki.endpoint\")<br>  private val storePath = cfg.get[String](\"webpki.certificateStorePath\")<br>  private val timeoutMs = cfg.get[Int](\"webpki.timeoutMs\")<br>  private val client = HttpClient.newBuilder().connectTimeout(Duration.ofMillis(timeoutMs)).build()<br>  private def save(name: String, data: Array[Byte]): Unit = {<br>    Files.createDirectories(Paths.get(storePath))<br>    Files.write(Paths.get(storePath, name), data)<br>  }<br>  def enroll(subject: String, machineId: String): Future[Array[Byte]] = {<br>    val initBytes = cmpMessage.createInitRequest(subject)<br>    val req = HttpRequest.newBuilder(URI.create(endpoint))<br>      .timeout(Duration.ofMillis(timeoutMs))<br>      .header(\"Content-Type\", \"application/pkixcmp\")<br>      .POST(BodyPublishers.ofByteArray(initBytes))<br>      .build()<br>    client.sendAsync(req, BodyHandlers.ofByteArray()).thenCompose { resp =&gt;<br>      val body = resp.body()<br>      val pkiResp = /* you need parse bytes into PKIMessage; wrap in WSResponse-like helper */ {<br>        // For simplicity reuse a small adapter: parse bytes into PKIMessage (left as exercise)<br>        null<br>      }<br>      // In practice you'd convert bytes to PKIMessage and call createConfirmRequest<br>      // For demo we simply persist the response bytes and return them<br>      save(s\"$machineId-init.pki\", body)<br>      java.util.concurrent.CompletableFuture.completedFuture(body)<br>    }.asScala<br>  }<br>}</pre>\n<blockquote>The Java client version intentionally leaves the PKIMessage adaptation minimalâ€Šâ€”â€Šthe key idea is: you can use any HTTP client that posts application/pkixcmp bytes and reads the raw bytes back. Use BouncyCastle to parse the PKIÂ message.</blockquote>\n<h3>7â€Šâ€”â€ŠBuilding a PKCS#12 (production note)</h3>\n<p>Often EJBCA willÂ return:</p>\n<ul>\n<li>certificate chain, and optionally</li>\n<li>an encrypted private key that must be unwrapped with your Protocol PrivateÂ Key.</li>\n</ul>\n<p><strong>Production flow:</strong></p>\n<ol>\n<li>Use your protocol private key to unwrap the symmetric key (as shown in your original decryptPrivateKey logic).</li>\n<li>Decrypt private key bytes and combine with certificate chain to create a KeyStore of type PKCS12, then store() it to disk (orÂ S3).</li>\n<li>Protect the PKCS#12 password with your secret manager (KMS). In production we used <strong>KMS</strong> for password encryption and <strong>S3</strong> for backup of PKCS#12 files. This ensures you can recover certificates and keep them encrypted atÂ rest.</li>\n</ol>\n<h3>8â€Šâ€”â€ŠRenewal &amp; Revocation: when &amp;Â how</h3>\n<ul>\n<li>\n<strong>Renewal</strong>: Request a new certificate when expiry is near. CMP renewal usually looks like an init request with renewal controls or re-using existing CMP request flow. Some CMP servers accept ExplicitConfirm or specific controls. Test against your EJBCA configuration.</li>\n<li>\n<strong>Revocation</strong>: You can revoke via CMP (CMP supports revocation messages) or via EJBCA REST/CLI/admin endpoints. In many enterprise setups, RA systems call EJBCAâ€™s REST API for revocation since itâ€™s simpler to authenticate.</li>\n</ul>\n<h3>9â€Šâ€”â€ŠCommon pitfalls &amp; troubleshooting</h3>\n<ul>\n<li>\n<strong>Wrong shared secret</strong> â†’ PKMAC validation fails; EJBCA returns ErrorMsgContent. Check alias configuration andÂ secret.</li>\n<li>\n<strong>Certificates not present</strong> â†’ Ensure CA is allowed for CMP alias and the CA has the proper issuing certificate.</li>\n<li>\n<strong>Clock skew</strong> â†’ CMP messages include timestamps. Sync servers viaÂ NTP.</li>\n<li>\n<strong>Missing protocol keys</strong> â†’ If CA expects ProtocolEncrKeyControl, ensure you provide the CA public key in your CRMFÂ control.</li>\n<li>\n<strong>Content-Type</strong>: CMP HTTP expects application/pkixcmp for many deployments; ensure client sets thatÂ header.</li>\n</ul>\n<h3>10â€Šâ€”â€ŠSecurity &amp; production checklist</h3>\n<ul>\n<li>Use HTTPS endpoints for CMP (TLS). If using plain HTTP for testing, never do that in production.</li>\n<li>Protect <strong>macSecret</strong>, protocol private key, and PKCS#12 passwords using a secret manager. In production, we used <strong>AWS KMS</strong> to encrypt passwords and <strong>S3</strong> to store PKCS#12 blobsâ€Šâ€”â€Škeep them encrypted at rest and only decrypt in memory whenÂ needed.</li>\n<li>Rotate shared secrets and protocol keys according toÂ policy.</li>\n<li>Log <strong>only</strong> non-sensitive metadata. Do not log private key material or PKCS#12 password.</li>\n</ul>\n<h3>11â€Šâ€”â€ŠConclusion</h3>\n<p>Integrating EJBCA Community Edition with Scala is straightforward once CMP is enabled on the CA and you have the right cryptographic controls. This guide focused on core flows (Init + Confirm), renewal and revocation examples, and two client implementations (Play WSClient and Java 11 HttpClient). For production-grade deployments, combine CMP with secure key storage to keep certificate material safe and recoverable <em>(e.g., AWS KMS for protection and S3 for encrypted backups)</em>.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=72330b4da4e5\" width=\"1\" height=\"1\" alt=\"\">\n",
      "enclosure": {},
      "categories": [
        "play-framework",
        "scala",
        "ejbca",
        "public-key-infrastructure",
        "certificate-management"
      ]
    },
    {
      "title": "Smarter Tolls, Smoother Commutes: An AI Idea for Hong Kongâ€™s Traffic",
      "pubDate": "2025-10-01 15:27:59",
      "link": "https://medium.com/@ali_farooqi/smarter-tolls-smoother-commutes-an-ai-idea-for-hong-kongs-traffic-6c67601587ac?source=rss-195ef3d05aae------2",
      "guid": "https://medium.com/p/6c67601587ac",
      "author": "Ali Farooqi",
      "thumbnail": "",
      "description": "\n<p>I live in Yuen Long. On some days, I need to drive into Kowloon or even across to Hong Kong Island. Every time, Iâ€™m reminded of one of the biggest frustrations of living in the Northwest New Territories: <strong>traffic bottlenecks</strong>.</p>\n<p>For those of us in Yuen Long or Tuen Mun, the commute is unpredictable at best, exhausting at worst. There are really only two main ways out: take the <strong>Tai Lam Tunnel</strong> or the <strong>Tuen Mun Road / NT CircularÂ Road</strong>.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*FMWXnkjK0hxwziq7XCGTzQ.jpeg\"><figcaption>Tai LamÂ Tunnel</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*lwQ46y6ux17XmchWRRz7lw.jpeg\"><figcaption>Tuen Mun/NT CircularÂ Road</figcaption></figure><p>Hereâ€™s the problem: during rush hours, when tolls for Tai Lam Tunnel are <strong>higher <em>(</em></strong><em>$45 in the morning and evening peak time slots on weekdays, compared to $30 during normal time slot at the time of writing</em><strong><em>)</em></strong>, many drivers avoid it altogether. Instead, they head for Tuen Mun Road, clogging it up with cars and trucks. For commuters, that means sitting in endless queues. For delivery drivers, it means delays that ripple across the whole logistics chain. For residents of Tuen Mun, it means thereâ€™s often <strong>no escape</strong> from congestionÂ .</p>\n<blockquote><strong>The higher tolls nudge people away from the tunnel at the very time itâ€™s neededÂ most.</strong></blockquote>\n<p>The Hong Kong government knows this is a serious problem. Thatâ€™s why theyâ€™re planning <a href=\"https://route11.hk/\"><strong>Route 11</strong></a>, a massive new highway that will link Northwest New Territories to urban Kowloon. Itâ€™s an ambitious and necessary project, but it comes with a billion-dollar price tag and wonâ€™t be ready at least until 2033. Meanwhile, the government is pushing ahead with the <strong>Northern Metropolis development</strong>, which means more residents, more businesses, and more cars on the road. Without interim solutions, congestion will only getÂ worse.</p>\n<p>Thatâ€™s where our idea comes in. We asked ourselves: <em>what if we could use something far simpler: human psychology, powered by AI to balance traffic rightÂ now?</em></p>\n<p>The concept is straightforward: people make driving choices based on <strong>time and cost</strong>. By adjusting the <strong>toll price dynamically</strong>, we can nudge drivers toward or away from Tai Lam Tunnel depending on live traffic conditions. ForÂ example:</p>\n<ul>\n<li>If NT Circular Road is jammed and Tai Lam Tunnel has spare capacity, the toll could drop temporarily, encouraging drivers toÂ switch.</li>\n<li>If Tai Lam Tunnel is nearing saturation, the toll could rise slightly to balanceÂ flows.</li>\n</ul>\n<p>This isnâ€™t just theory. In June 2025, when the government took over Tai Lam Tunnel and <strong>reduced tolls</strong>, traffic through the tunnel jumped <strong>10% in just one day </strong><em>(source: </em><a href=\"https://www.scmp.com/news/hong-kong/transport/article/3312710/traffic-hong-kongs-tai-lam-tunnel-10-first-day-under-government-control\"><em>SCMP</em></a><em>)</em>. Thatâ€™s a clear signal: <strong>toll price directly shapes driver behavior</strong>.</p>\n<p>Our projectâ€Šâ€”â€Š<strong>Smart Dynamic Tolling</strong>â€Šâ€”â€Šuses open data from Hong Kongâ€™s Transport Department. We built an AI-powered simulator that ingests real-time traffic detector data, weather, and even event schedules. The system predicts congestion and recommends optimal toll adjustments every 15Â minutes.</p>\n<p>The idea is not to squeeze drivers, but to smooth out usage, reduce peak bottlenecks, and keep tunnel revenues steady. And crucially, itâ€™s <strong>transparent</strong>: new tolls can be displayed on tunnel signboards and even integrated into GPS apps like Google Maps or Waze. That way, drivers immediately see the updated cost and the time theyâ€™llÂ save.</p>\n<p>Itâ€™s a temporary fix, but one that could provide <strong>real relief</strong> while we wait for big projects like Route 11. Itâ€™s affordable, scalable, and doesnâ€™t require tearing up roadsâ€¦ Just smarter use of the infrastructure we alreadyÂ have.</p>\n<p>For those of us living in Yuen Long, Tuen Mun, and the broader Northern Metropolis, solutions like this could mean fewer wasted hours in traffic and more time where itÂ matters.</p>\n<p>Hong Kong has always been a city of bold infrastructure. But sometimes, the smartest solutions are the simplest, powered by data, psychology, and a little bit ofÂ AI.</p>\n<p><em>If you are interested to learn more about the project, you can find the code on our </em><a href=\"https://github.com/shusaan/tai_lam_traffic_simulator/\"><em>GitHub</em></a><em> or check out the quick demo we developed using traffic simulator </em><a href=\"https://hk-traffic.aiopscraft.cloud/\"><em>here</em></a><em>.</em></p>\n<p><em>P.S. We use traditional AI models to predict the traffic data, not the LLMsÂ </em>ğŸ™ğŸ¼</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=6c67601587ac\" width=\"1\" height=\"1\" alt=\"\">\n",
      "content": "\n<p>I live in Yuen Long. On some days, I need to drive into Kowloon or even across to Hong Kong Island. Every time, Iâ€™m reminded of one of the biggest frustrations of living in the Northwest New Territories: <strong>traffic bottlenecks</strong>.</p>\n<p>For those of us in Yuen Long or Tuen Mun, the commute is unpredictable at best, exhausting at worst. There are really only two main ways out: take the <strong>Tai Lam Tunnel</strong> or the <strong>Tuen Mun Road / NT CircularÂ Road</strong>.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*FMWXnkjK0hxwziq7XCGTzQ.jpeg\"><figcaption>Tai LamÂ Tunnel</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*lwQ46y6ux17XmchWRRz7lw.jpeg\"><figcaption>Tuen Mun/NT CircularÂ Road</figcaption></figure><p>Hereâ€™s the problem: during rush hours, when tolls for Tai Lam Tunnel are <strong>higher <em>(</em></strong><em>$45 in the morning and evening peak time slots on weekdays, compared to $30 during normal time slot at the time of writing</em><strong><em>)</em></strong>, many drivers avoid it altogether. Instead, they head for Tuen Mun Road, clogging it up with cars and trucks. For commuters, that means sitting in endless queues. For delivery drivers, it means delays that ripple across the whole logistics chain. For residents of Tuen Mun, it means thereâ€™s often <strong>no escape</strong> from congestionÂ .</p>\n<blockquote><strong>The higher tolls nudge people away from the tunnel at the very time itâ€™s neededÂ most.</strong></blockquote>\n<p>The Hong Kong government knows this is a serious problem. Thatâ€™s why theyâ€™re planning <a href=\"https://route11.hk/\"><strong>Route 11</strong></a>, a massive new highway that will link Northwest New Territories to urban Kowloon. Itâ€™s an ambitious and necessary project, but it comes with a billion-dollar price tag and wonâ€™t be ready at least until 2033. Meanwhile, the government is pushing ahead with the <strong>Northern Metropolis development</strong>, which means more residents, more businesses, and more cars on the road. Without interim solutions, congestion will only getÂ worse.</p>\n<p>Thatâ€™s where our idea comes in. We asked ourselves: <em>what if we could use something far simpler: human psychology, powered by AI to balance traffic rightÂ now?</em></p>\n<p>The concept is straightforward: people make driving choices based on <strong>time and cost</strong>. By adjusting the <strong>toll price dynamically</strong>, we can nudge drivers toward or away from Tai Lam Tunnel depending on live traffic conditions. ForÂ example:</p>\n<ul>\n<li>If NT Circular Road is jammed and Tai Lam Tunnel has spare capacity, the toll could drop temporarily, encouraging drivers toÂ switch.</li>\n<li>If Tai Lam Tunnel is nearing saturation, the toll could rise slightly to balanceÂ flows.</li>\n</ul>\n<p>This isnâ€™t just theory. In June 2025, when the government took over Tai Lam Tunnel and <strong>reduced tolls</strong>, traffic through the tunnel jumped <strong>10% in just one day </strong><em>(source: </em><a href=\"https://www.scmp.com/news/hong-kong/transport/article/3312710/traffic-hong-kongs-tai-lam-tunnel-10-first-day-under-government-control\"><em>SCMP</em></a><em>)</em>. Thatâ€™s a clear signal: <strong>toll price directly shapes driver behavior</strong>.</p>\n<p>Our projectâ€Šâ€”â€Š<strong>Smart Dynamic Tolling</strong>â€Šâ€”â€Šuses open data from Hong Kongâ€™s Transport Department. We built an AI-powered simulator that ingests real-time traffic detector data, weather, and even event schedules. The system predicts congestion and recommends optimal toll adjustments every 15Â minutes.</p>\n<p>The idea is not to squeeze drivers, but to smooth out usage, reduce peak bottlenecks, and keep tunnel revenues steady. And crucially, itâ€™s <strong>transparent</strong>: new tolls can be displayed on tunnel signboards and even integrated into GPS apps like Google Maps or Waze. That way, drivers immediately see the updated cost and the time theyâ€™llÂ save.</p>\n<p>Itâ€™s a temporary fix, but one that could provide <strong>real relief</strong> while we wait for big projects like Route 11. Itâ€™s affordable, scalable, and doesnâ€™t require tearing up roadsâ€¦ Just smarter use of the infrastructure we alreadyÂ have.</p>\n<p>For those of us living in Yuen Long, Tuen Mun, and the broader Northern Metropolis, solutions like this could mean fewer wasted hours in traffic and more time where itÂ matters.</p>\n<p>Hong Kong has always been a city of bold infrastructure. But sometimes, the smartest solutions are the simplest, powered by data, psychology, and a little bit ofÂ AI.</p>\n<p><em>If you are interested to learn more about the project, you can find the code on our </em><a href=\"https://github.com/shusaan/tai_lam_traffic_simulator/\"><em>GitHub</em></a><em> or check out the quick demo we developed using traffic simulator </em><a href=\"https://hk-traffic.aiopscraft.cloud/\"><em>here</em></a><em>.</em></p>\n<p><em>P.S. We use traditional AI models to predict the traffic data, not the LLMsÂ </em>ğŸ™ğŸ¼</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=6c67601587ac\" width=\"1\" height=\"1\" alt=\"\">\n",
      "enclosure": {},
      "categories": [
        "random-forest-model",
        "ai",
        "smart-traffic-management",
        "hong-kong",
        "psychology"
      ]
    }
  ]
}
